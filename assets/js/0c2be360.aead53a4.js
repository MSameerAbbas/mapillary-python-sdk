"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[2296],{3905:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>d});var n=a(7294);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function r(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?r(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):r(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,i=function(e,t){if(null==e)return{};var a,n,i={},r=Object.keys(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);for(n=0;n<r.length;n++)a=r[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var p=n.createContext({}),s=function(e){var t=n.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},m=function(e){var t=s(e.components);return n.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},c=n.forwardRef((function(e,t){var a=e.components,i=e.mdxType,r=e.originalType,p=e.parentName,m=o(e,["components","mdxType","originalType","parentName"]),c=s(a),d=i,k=c["".concat(p,".").concat(d)]||c[d]||u[d]||r;return a?n.createElement(k,l(l({ref:t},m),{},{components:a})):n.createElement(k,l({ref:t},m))}));function d(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var r=a.length,l=new Array(r);l[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:i,l[1]=o;for(var s=2;s<r;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}c.displayName="MDXCreateElement"},4853:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>l,default:()=>m,frontMatter:()=>r,metadata:()=>o,toc:()=>p});var n=a(7462),i=(a(7294),a(3905));const r={"sidebar position":2},l=void 0,o={unversionedId:"mapillary/mapillary.interface",id:"mapillary/mapillary.interface",isDocsHomePage:!1,title:"mapillary.interface",description:"mapillary.interface",source:"@site/docs/mapillary/mapillary.interface.md",sourceDirName:"mapillary",slug:"/mapillary/mapillary.interface",permalink:"/mapillary-python-sdk/docs/mapillary/mapillary.interface",editUrl:"https://github.com/mapillary/mapillary-python-sdk/tree/main/docs/docs/mapillary/mapillary.interface.md",tags:[],version:"current",frontMatter:{"sidebar position":2},sidebar:"tutorialSidebar",previous:{title:"mapillary.utils.verify",permalink:"/mapillary-python-sdk/docs/mapillary.utils/mapillary.utils.verify"},next:{title:"mapillary",permalink:"/mapillary-python-sdk/docs/mapillary/mapillary"}},p=[{value:"mapillary.interface",id:"mapillaryinterface",children:[]},{value:"mapillary.interface.feature_from_key(key: str, fields: list = [])",id:"mapillaryinterfacefeature_from_keykey-str-fields-list--",children:[]},{value:"mapillary.interface.get_detections_with_image_id(image_id: int, fields: list = [])",id:"mapillaryinterfaceget_detections_with_image_idimage_id-int-fields-list--",children:[]},{value:"mapillary.interface.get_detections_with_map_feature_id(map_feature_id: str, fields: list = None)",id:"mapillaryinterfaceget_detections_with_map_feature_idmap_feature_id-str-fields-list--none",children:[]},{value:"mapillary.interface.get_image_close_to(latitude=-122.1504711, longitude=37.485073, **kwargs)",id:"mapillaryinterfaceget_image_close_tolatitude-1221504711-longitude37485073-kwargs",children:[]},{value:"mapillary.interface.get_image_looking_at(at: dict, **filters: dict)",id:"mapillaryinterfaceget_image_looking_atat-dict-filters-dict",children:[]},{value:"mapillary.interface.image_from_key(key: str, fields: list = None)",id:"mapillaryinterfaceimage_from_keykey-str-fields-list--none",children:[]},{value:"mapillary.interface.image_thumbnail(image_id: str, resolution: int = 1024)",id:"mapillaryinterfaceimage_thumbnailimage_id-str-resolution-int--1024",children:[]},{value:"mapillary.interface.images_in_bbox(bbox: dict, **filters)",id:"mapillaryinterfaceimages_in_bboxbbox-dict-filters",children:[]},{value:"mapillary.interface.images_in_geojson(geojson: dict, **filters: dict)",id:"mapillaryinterfaceimages_in_geojsongeojson-dict-filters-dict",children:[]},{value:"mapillary.interface.images_in_shape(shape, **filters: dict)",id:"mapillaryinterfaceimages_in_shapeshape-filters-dict",children:[]},{value:"mapillary.interface.is_image_being_looked_at(at: Uniondict, Coordinates, list, **filters: dict)",id:"mapillaryinterfaceis_image_being_looked_atat-uniondict-coordinates-list-filters-dict",children:[]},{value:"mapillary.interface.map_feature_points_in_bbox(bbox: dict, filter_values: list = None, **filters: dict)",id:"mapillaryinterfacemap_feature_points_in_bboxbbox-dict-filter_values-list--none-filters-dict",children:[]},{value:"mapillary.interface.map_features_in_geojson(geojson: dict, **filters: dict)",id:"mapillaryinterfacemap_features_in_geojsongeojson-dict-filters-dict",children:[]},{value:"mapillary.interface.map_features_in_shape(shape: dict, **filters: dict)",id:"mapillaryinterfacemap_features_in_shapeshape-dict-filters-dict",children:[]},{value:"mapillary.interface.save_locally(geojson_data: str, file_path: str = &#39;/home/saif/Projects/mapillary-python-sdk/src/mapillary&#39;, file_name: str = None, extension: str = &#39;geojson&#39;)",id:"mapillaryinterfacesave_locallygeojson_data-str-file_path-str--homesaifprojectsmapillary-python-sdksrcmapillary-file_name-str--none-extension-str--geojson",children:[]},{value:"mapillary.interface.sequences_in_bbox(bbox: dict, **filters)",id:"mapillaryinterfacesequences_in_bboxbbox-dict-filters",children:[]},{value:"mapillary.interface.set_access_token(token: str)",id:"mapillaryinterfaceset_access_tokentoken-str",children:[]},{value:"mapillary.interface.traffic_signs_in_bbox(bbox: dict, filter_values: list = None, **filters: dict)",id:"mapillaryinterfacetraffic_signs_in_bboxbbox-dict-filter_values-list--none-filters-dict",children:[]},{value:"Module contents",id:"module-contents",children:[{value:"mapillary.<strong>init</strong>",id:"mapillaryinit",children:[]}]}],s={toc:p};function m(e){let{components:t,...a}=e;return(0,i.kt)("wrapper",(0,n.Z)({},s,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"mapillaryinterface"},"mapillary.interface"),(0,i.kt)("p",null,"This module implements the basic functionalities of the Mapillary Python SDK, a Python\nimplementation of the Mapillary API v4. For more information, please check out\n",(0,i.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"License: MIT LICENSE")),(0,i.kt)("h3",{id:"mapillaryinterfacefeature_from_keykey-str-fields-list--"},"mapillary.interface.feature_from_key(key: str, fields: list = [])"),(0,i.kt)("p",null,"Gets a map feature for the given key argument"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"key")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The map feature ID to which will be used to get the feature")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **fields** (*list*) \u2013 The fields to include. The field \u2018geometry\u2019 will always be included\nso you do not need to specify it, or if you leave it off, it will still be returned.\n\nFields:\n\n```\n1. first_seen_at - timestamp, timestamp of the least recent\n    detection contributing to this feature\n2. last_seen_at - timestamp, timestamp of the most recent\n    detection contributing to this feature\n3. object_value - string, what kind of map feature it is\n4. object_type - string, either a traffic_sign or point\n5. geometry - GeoJSON Point geometry\n6. images - list of IDs, which images this map feature was derived\nfrom\n```\n\nRefer to [https://www.mapillary.com/developer/api-documentation/#map-feature](https://www.mapillary.com/developer/api-documentation/#map-feature) for more details\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A GeoJSON string that represents the queried feature"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  str"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.feature_from_key(\n...     key='VALID_MAP_FEATURE_KEY',\n...     fields=['object_value']\n... )\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceget_detections_with_image_idimage_id-int-fields-list--"},"mapillary.interface.get_detections_with_image_id(image_id: int, fields: list = [])"),(0,i.kt)("p",null,"Extracting all the detections within an image using an image key"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image_id")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The image key as the argument")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **fields** (*list*) \u2013 The fields possible for the detection endpoint. Please see\n[https://www.mapillary.com/developer/api-documentation](https://www.mapillary.com/developer/api-documentation) for more information\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The GeoJSON in response"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  dict"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'>>> import mapillary as mly\n>>> mly.interface.set_access_token(\'CLIENT_TOKEN_HERE\')\n>>> mly.interface.get_detections_with_image_id(image_id=1933525276802129)\n... {"data":[{"created_at":"2021-05-20T17:49:01+0000","geometry":\n... "GjUKBm1weS1vchIVEgIAABgDIg0JhiekKBoqAABKKQAPGgR0eXBlIgkKB3BvbHlnb24ogCB4AQ==","image"\n... :{"geometry":{"type":"Point","coordinates":[-97.743279722222,30.270651388889]},"id":\n... "1933525276802129"},"value":"regulatory--no-parking--g2","id":"1942105415944115"},\n... {"created_at":"2021-05-20T18:40:21+0000","geometry":\n... "GjYKBm1weS1vchIWEgIAABgDIg4J7DjqHxpWAADiAVUADxoEdHlwZSIJCgdwb2x5Z29uKIAgeAE=",\n... "image":{"geometry":{"type":"Point","coordinates":[-97.743279722222,30.270651388889]},\n... "id":"1933525276802129"},"value":"information--parking--g1","id":"1942144785940178"},\n... , ...}\n')),(0,i.kt)("h3",{id:"mapillaryinterfaceget_detections_with_map_feature_idmap_feature_id-str-fields-list--none"},"mapillary.interface.get_detections_with_map_feature_id(map_feature_id: str, fields: list = None)"),(0,i.kt)("p",null,"Extracting all detections made for a map feature key"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"map_feature_id")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 A map feature key as the argument")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **fields** (*list*) \u2013 The fields possible for the detection endpoint. Please see\n[https://www.mapillary.com/developer/api-documentation](https://www.mapillary.com/developer/api-documentation) for more information\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The GeoJSON in response"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  GeoJSON"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.get_detections_with_map_feature_id(map_feature_id='1933525276802129')\n...     File \"/home/saif/MLH/mapillary-python-sdk/mapillary/controller/rules/verify.py\",\n...         line 227, in valid_id\n...             raise InvalidOptionError(\n... mly.models.exceptions.InvalidOptionError: InvalidOptionError: Given id value,\n...     \"Id: 1933525276802129, image: False\" while possible id options, [Id is image_id\n...     AND image is True, key is map_feature_id ANDimage is False]\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceget_image_close_tolatitude-1221504711-longitude37485073-kwargs"},"mapillary.interface.get_image_close_to(latitude=-122.1504711, longitude=37.485073, ","*","*","kwargs)"),(0,i.kt)("p",null,"Function that takes a longitude, latitude as argument and outputs the near images. This\nmakes an API call with the token set in set_access_token and returns a JSON object."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"longitude")," (",(0,i.kt)("em",{parentName:"li"},"float",(0,i.kt)("strong",{parentName:"em"}," or "),"double"),") \u2013 The longitude")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **latitude** (*float** or **double*) \u2013 The latitude\n\n\n* **kwargs.fields** (*list*) \u2013 A list of options, either as [\u2018all\u2019], or a list of fields.\nSee [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/), under \u2018Fields\u2019 for more insight.\n\n\n* **kwargs.zoom** (*int*) \u2013 The zoom level of the tiles to obtain, defaults to 14\n\n\n* **kwargs.radius** (*float** or **int** or **double*) \u2013 The radius of the images obtained from a center center\n\n\n* **kwargs.image_type** (*str*) \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018both\u2019. See [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/) under\n\u2018image_type Tiles\u2019 for more information\n\n\n* **kwargs.min_captured_at** (*str*) \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **kwargs.max_captured_at** (*str*) \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **kwargs.org_id** (*int*) \u2013 The organization id, ID of the organization this image (or sets of\nimages) belong to. It can be absent. Thus, default is -1 (None)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  GeoJSON"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  dict"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('CLIENT_TOKEN_HERE')\n>>> mly.interface.get_image_close_to(longitude=31, latitude=30)\n... {'type': 'FeatureCollection', 'features': [{'type': 'Feature',\n'geometry': {'type': 'Point', 'coordinates': [30.9912246465683,\n29.99794091267283]}, 'properties': {'captured_at': 1621008070596,\n'compass_angle': 322.56726074219, 'id': 499412381300321, 'is_pano':\nFalse, 'sequence_id': '94afmyyhq85xd9bi8p44ve'}} ...\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceget_image_looking_atat-dict-filters-dict"},"mapillary.interface.get_image_looking_at(at: dict, ","*","*","filters: dict)"),(0,i.kt)("p",null,"Function that takes two sets of latitude and longitude, where the 2nd set is the\n\u201clooking at\u201d location from 1st set\u2019s perspective argument and outputs the near images. This\nmakes an API call with the token set in set_access_token and returns a JSON object."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"at")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The coordinate sets to where a certain point is being looked at"),(0,i.kt)("p",{parentName:"li"},"Format:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {\n...     'lng': 'longitude',\n...     'lat': 'latitude'\n... }\n")))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filters.min_captured_at** (*str*) \u2013 The minimum date to filter till\n\n\n* **filters.max_captured_at** (*str*) \u2013 The maximum date to filter upto\n\n\n* **filters.radius** (*float*) \u2013 The radius that the geometry points will lie in\n\n\n* **filters.image_type** (*str*) \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019\n\n\n* **filters.organization_id** (*str*) \u2013 The organization to retrieve the data for\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The GeoJSON response containing relevant features"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  GeoJSON"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> data = mly.interface.get_image_looking_at(\n...         at={\n...             'lng': 12.955075073889,\n...             'lat': 48.053805939722,\n...         },\n...         radius = 5000,\n...     )\n>>> data\n... {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry': {'type':\n... 'Point', 'coordinates': [12.954479455947876, 48.05091893670834]}, 'properties':\n... {'captured_at': 1612606959408, 'compass_angle': 21.201110839844, 'id': 1199705400459580,\n... 'is_pano': False, 'sequence_id': 'qrrqtke4a6vtygyc7w8rzc'}}, ... }\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceimage_from_keykey-str-fields-list--none"},"mapillary.interface.image_from_key(key: str, fields: list = None)"),(0,i.kt)("p",null,"Gets an image for the given key argument"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"key")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The image unique key which will be used for image retrieval")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **fields** (*list*) \u2013 The fields to include. The field \u2018geometry\u2019 will always be included\nso you do not need to specify it, or if you leave it off, it will still be returned.\n\nFields,\n\n\n    1. altitude - float, original altitude from Exif\n\n\n    2. atomic_scale - float, scale of the SfM reconstruction around the image\n\n\n    3. camera_parameters - array of float, intrinsic camera parameters\n\n\n    4. camera_type - enum, type of camera projection (perspective, fisheye, or\n\n    spherical)\n\n\n    5. captured_at - timestamp, capture time\n\n\n    6. compass_angle - float, original compass angle of the image\n\n\n    7. computed_altitude - float, altitude after running image processing\n\n\n    8. computed_compass_angle - float, compass angle after running image processing\n\n\n    9. computed_geometry - GeoJSON Point, location after running image processing\n\n\n    10. computed_rotation - enum, corrected orientation of the image\n\n\n    11. exif_orientation - enum, orientation of the camera as given by the exif tag\n(see: [https://sylvana.net/jpegcrop/exif_orientation.html](https://sylvana.net/jpegcrop/exif_orientation.html))\n\n\n    12. geometry - GeoJSON Point geometry\n\n\n    13. height - int, height of the original image uploaded\n\n\n    14. thumb_256_url - string, URL to the 256px wide thumbnail\n\n\n    15. thumb_1024_url - string, URL to the 1024px wide thumbnail\n\n\n    16. thumb_2048_url - string, URL to the 2048px wide thumbnail\n\n\n    17. merge_cc - int, id of the connected component of images that were aligned\ntogether\n\n\n    18. mesh - { id: string, url: string } - URL to the mesh\n\n\n    19. quality_score - float, how good the image is (experimental)\n\n\n    20. sequence - string, ID of the sequence\n\n\n    21. sfm_cluster - { id: string, url: string } - URL to the point cloud\n\n\n    22. width - int, width of the original image uploaded\n\nRefer to [https://www.mapillary.com/developer/api-documentation/#image](https://www.mapillary.com/developer/api-documentation/#image) for more details\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A GeoJSON string that represents the queried image"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  str"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.image_from_key(\n...     key='VALID_IMAGE_KEY',\n...     fields=['captured_at', 'sfm_cluster', 'width']\n... )\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceimage_thumbnailimage_id-str-resolution-int--1024"},"mapillary.interface.image_thumbnail(image_id: str, resolution: int = 1024)"),(0,i.kt)("p",null,"Gets the thumbnails of images from the API"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image_id")," \u2013 Image key as the argument")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **resolution** \u2013 Option for the thumbnail size, with available resolutions:\n256, 1024, and 2048\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A URL for the thumbnail"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  str"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.image_thumbnail(\n...     image_id='IMAGE_ID_HERE', resolution=1024\n... )\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceimages_in_bboxbbox-dict-filters"},"mapillary.interface.images_in_bbox(bbox: dict, ","*","*","filters)"),(0,i.kt)("p",null,"Gets a complete list of images with custom filter within a BBox"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"bbox")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 Bounding box coordinates"),(0,i.kt)("p",{parentName:"li"},"Format:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {\n...     'west': 'BOUNDARY_FROM_WEST',\n...     'south': 'BOUNDARY_FROM_SOUTH',\n...     'east': 'BOUNDARY_FROM_EAST',\n...     'north': 'BOUNDARY_FROM_NORTH'\n... }\n")))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filters** (*dict*) \u2013 Different filters that may be applied to the output\n\nExample filters:\n\n```\n- max_captured_at\n- min_captured_at\n- image_type: pano, flat, or all\n- compass_angle\n- sequence_id\n- organization_id\n```\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Output is a GeoJSON string that represents all the within a bbox after passing given\nfilters"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  str"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.images_in_bbox(\n...     bbox={\n...         'west': 'BOUNDARY_FROM_WEST',\n...         'south': 'BOUNDARY_FROM_SOUTH',\n...         'east': 'BOUNDARY_FROM_EAST',\n...         'north': 'BOUNDARY_FROM_NORTH'\n...     },\n...     max_captured_at='YYYY-MM-DD HH:MM:SS',\n...     min_captured_at='YYYY-MM-DD HH:MM:SS',\n...     image_type='pano',\n...     compass_angle=(0, 360),\n...     sequence_id='SEQUENCE_ID',\n...     organization_id='ORG_ID'\n... )\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceimages_in_geojsongeojson-dict-filters-dict"},"mapillary.interface.images_in_geojson(geojson: dict, ","*","*","filters: dict)"),(0,i.kt)("p",null,"Extracts all images within a shape"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 A geojson as the shape acting as the query extent")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filters** (*dict** (**kwargs**)*) \u2013 Different filters that may be applied to the output, defaults to {}\n\n\n* **filters.max_captured_at** (*str*) \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.min_captured_at** (*str*) \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.image_type** (*str*) \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/) under\n\u2018image_type Tiles\u2019 for more information\n\n\n* **filters.compass_angle** (*int*) \u2013 The compass angle of the image\n\n\n* **filters.sequence_id** (*str*) \u2013 ID of the sequence this image belongs to\n\n\n* **filters.organization_id** (*str*) \u2013 ID of the organization this image belongs to. It can be absent\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A GeoJSON object"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  mapillary.models.geojson.GeoJSON"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> from mapillary.models.geojson import GeoJSON\n>>> import json\n>>> mly.interface.set_access_token('MLY|YYY')\n>>> data = mly.interface.images_in_geojson(json.load(open('my_geojson.geojson', mode='r')))\n>>> open('output_geojson.geojson', mode='w').write(data.encode())\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceimages_in_shapeshape-filters-dict"},"mapillary.interface.images_in_shape(shape, ","*","*","filters: dict)"),(0,i.kt)("p",null,"Extracts all images within a shape or polygon."),(0,i.kt)("p",null,"Format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'>>> {\n...    "type": "FeatureCollection",\n...     "features": [\n...        {\n...             "type": "Feature",\n...             "properties": {},\n...             "geometry": {\n...                 "type": "Polygon",\n...                 "coordinates": [\n...                     [\n...                         [\n...                             7.2564697265625,\n...                             43.69716905314008\n...                         ],\n...                         ...\n...                     ]\n...                 ]\n...             }\n...         }\n...     ]\n... }\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"shape")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 A shape that describes features, formatted as a geojson")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filters** (*dict** (**kwargs**)*) \u2013 Different filters that may be applied to the output, defaults to {}\n\n\n* **filters.max_captured_at** (*str*) \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.min_captured_at** (*str*) \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.image_type** (*str*) \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/) under\n\u2018image_type Tiles\u2019 for more information\n\n\n* **filters.compass_angle** (*int*) \u2013 The compass angle of the image\n\n\n* **filters.sequence_id** (*str*) \u2013 ID of the sequence this image belongs to\n\n\n* **filters.organization_id** (*str*) \u2013 ID of the organization this image belongs to. It can be absent\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A GeoJSON object"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  mapillary.models.geojson.GeoJSON"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> import json\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> data = mly.interface.images_in_shape(json.load(open('polygon.geojson', mode='r')))\n>>> open('output_geojson.geojson', mode='w').write(data.encode())\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceis_image_being_looked_atat-uniondict-coordinates-list-filters-dict"},"mapillary.interface.is_image_being_looked_at(at: Union","[dict, Coordinates, list]",", ","*","*","filters: dict)"),(0,i.kt)("p",null,"Function that two sets of coordinates and returns whether the image  with coordinates of \u201cat\u201d\nis looked at or not by the image with coordinates of \u201clooker\u201d."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"at")," (",(0,i.kt)("em",{parentName:"p"},"Union",(0,i.kt)("strong",{parentName:"em"},"["),"dict",(0,i.kt)("strong",{parentName:"em"},", "),"mapillary.models.geojson.Coordinates",(0,i.kt)("strong",{parentName:"em"},", "),"list**]"),") \u2013 The coordinate sets to where a certain point is being looked at"),(0,i.kt)("p",{parentName:"li"},"  Format:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> at_dict = {\n...     'lng': 'longitude',\n...     'lat': 'latitude'\n... }\n>>> at_list = [12.954940544167, 48.0537894275]\n>>> from mapillary.models.geojson import Coordinates\n>>> at_coord: Coordinates = Coordinates(lng=12.954940544167, lat=48.0537894275)\n")))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  True if the image is looked at, False otherwise"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  bool"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.is_image_being_looked_at(\n...         at={\n...             'lng': 12.955075073889,\n...             'lat': 48.053805939722,\n...         },\n...         radius=50,\n...     )\n... True\n>>> # OR\n>>> from mapillary.models.geojson import Coordinates\n>>> mly.interface.is_image_looked_at(\n...         at=Coordinates(lng=11.954940544167, lat=46.0537894275),\n...         radius=50,\n...     )\n... True\n")),(0,i.kt)("h3",{id:"mapillaryinterfacemap_feature_points_in_bboxbbox-dict-filter_values-list--none-filters-dict"},"mapillary.interface.map_feature_points_in_bbox(bbox: dict, filter_values: list = None, ","*","*","filters: dict)"),(0,i.kt)("p",null,"Extracts map feature points within a bounding box (bbox)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"bbox")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 bbox coordinates as the argument"),(0,i.kt)("p",{parentName:"li"},"Example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> _ = {\n...     'west': 'BOUNDARY_FROM_WEST',\n...     'south': 'BOUNDARY_FROM_SOUTH',\n...     'east': 'BOUNDARY_FROM_EAST',\n...     'north': 'BOUNDARY_FROM_NORTH'\n... }\n")))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filter_values** (*list*) \u2013 a list of filter values supported by the API\n\nExample:\n\n```\n>>> _ = ['object--support--utility-pole', 'object--street-light']\n```\n\n\n\n* **filters** (*dict*) \u2013 kwarg filters to be applied on the resulted GeoJSON\n\nChronological filters,\n\n\n    * *existed_at*: checks if a feature existed after a certain date depending on the time\n\n    it was first seen at.\n\n\n    * *existed_before*: filters out the features that existed after a given date\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  GeoJSON Object"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  dict"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.map_feature_points_in_bbox(\n...     bbox={\n...         'west': 'BOUNDARY_FROM_WEST',\n...         'south': 'BOUNDARY_FROM_SOUTH',\n...         'east': 'BOUNDARY_FROM_EAST',\n...         'north': 'BOUNDARY_FROM_NORTH'\n...     },\n...     filter_values=['object--support--utility-pole', 'object--street-light'],\n...     existed_at='YYYY-MM-DD HH:MM:SS',\n...     existed_before='YYYY-MM-DD HH:MM:SS'\n... )\n")),(0,i.kt)("h3",{id:"mapillaryinterfacemap_features_in_geojsongeojson-dict-filters-dict"},"mapillary.interface.map_features_in_geojson(geojson: dict, ","*","*","filters: dict)"),(0,i.kt)("p",null,"Extracts all map features within a geojson\u2019s boundaries"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 A geojson as the shape acting as the query extent")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filters** (*dict** (**kwargs**)*) \u2013 Different filters that may be applied to the output, defaults to {}\n\n\n* **filters.zoom** (*int*) \u2013 The zoom level of the tiles to obtain, defaults to 14\n\n\n* **filters.max_captured_at** (*str*) \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.min_captured_at** (*str*) \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.image_type** (*str*) \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/) under\n\u2018image_type Tiles\u2019 for more information\n\n\n* **filters.compass_angle** (*int*) \u2013 The compass angle of the image\n\n\n* **filters.sequence_id** (*str*) \u2013 ID of the sequence this image belongs to\n\n\n* **filters.organization_id** (*str*) \u2013 ID of the organization this image belongs to. It can be absent\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A GeoJSON object"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  mapillary.models.geojson.GeoJSON"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> import json\n>>> mly.interface.set_access_token('MLY|YYY')\n>>> data = mly.interface.map_features_in_geojson(\n...     json.load(\n...         open('my_geojson.geojson', mode='r')\n...     )\n... )\n>>> open('output_geojson.geojson', mode='w').write(data.encode())\n")),(0,i.kt)("h3",{id:"mapillaryinterfacemap_features_in_shapeshape-dict-filters-dict"},"mapillary.interface.map_features_in_shape(shape: dict, ","*","*","filters: dict)"),(0,i.kt)("p",null,"Extracts all map features within a shape/polygon"),(0,i.kt)("p",null,"Format:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'>>> _ = {\n...     "type": "FeatureCollection",\n...     "features": [\n...         {\n...             "type": "Feature",\n...             "properties": {},\n...             "geometry": {\n...                 "type": "Polygon",\n...                 "coordinates": [\n...                     [\n...                         [\n...                             7.2564697265625,\n...                             43.69716905314008\n...                         ],\n...                         ...\n...                     ]\n...                 ]\n...             }\n...         }\n...     ]\n... }\n')),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"shape")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 A shape that describes features, formatted as a geojson")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filters** (*dict** (**kwargs**)*) \u2013 Different filters that may be applied to the output, defaults to {}\n\n\n* **filters.zoom** (*int*) \u2013 The zoom level of the tiles to obtain, defaults to 14\n\n\n* **filters.max_captured_at** (*str*) \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.min_captured_at** (*str*) \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.image_type** (*str*) \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/) under\n\u2018image_type Tiles\u2019 for more information\n\n\n* **filters.compass_angle** (*int*) \u2013 The compass angle of the image\n\n\n* **filters.sequence_id** (*str*) \u2013 ID of the sequence this image belongs to\n\n\n* **filters.organization_id** (*str*) \u2013 ID of the organization this image belongs to. It can be absent\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A GeoJSON object"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  mapillary.models.geojson.GeoJSON"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> import json\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> data = mly.interface.map_features_in_shape(json.load(open('polygon.geojson', mode='r')))\n>>> open('output_geojson.geojson', mode='w').write(data.encode())\n")),(0,i.kt)("h3",{id:"mapillaryinterfacesave_locallygeojson_data-str-file_path-str--homesaifprojectsmapillary-python-sdksrcmapillary-file_name-str--none-extension-str--geojson"},"mapillary.interface.save_locally(geojson_data: str, file_path: str = '/home/saif/Projects/mapillary-python-sdk/src/mapillary', file_name: str = None, extension: str = 'geojson')"),(0,i.kt)("p",null,"This function saves the geojson data locally as a file\nwith the given file name, path, and format."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson_data")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The GeoJSON data to be stored")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **file_path** (*str*) \u2013 The path to save the data to. Defaults to the current directory path\n\n\n* **file_name** (*str*) \u2013 The name of the file to be saved. Defaults to \u2018geojson\u2019\n\n\n* **extension** (*str*) \u2013 The format to save the data as. Defaults to \u2018geojson\u2019\n")),(0,i.kt)("p",null,"Note:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"Allowed file format values at the moment are,\n    - geojson\n    - CSV\n")),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"TODO"),": More file format will be supported further in developemtn\n",(0,i.kt)("em",{parentName:"p"},"TODO"),": Suggestions and help needed at mapillary/mapillary-python-sdk!"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  None"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  None"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.save_locally(\n...     geojson_data=geojson_data,\n...     file_path=os.path.dirname(os.path.realpath(__file__)),\n...     file_name='test_geojson',\n...     extension='geojson'\n... )\n>>> mly.interface.save_locally(\n...     geojson_data=geojson_data,\n...     file_path=os.path.dirname(os.path.realpath(__file__)),\n...     file_name='local_geometries',\n...     extension='csv'\n... )\n")),(0,i.kt)("h3",{id:"mapillaryinterfacesequences_in_bboxbbox-dict-filters"},"mapillary.interface.sequences_in_bbox(bbox: dict, ","*","*","filters)"),(0,i.kt)("p",null,"Gets a complete list of all sequences of images that satisfy given filters\nwithin a BBox."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"bbox")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 Bounding box coordinates"),(0,i.kt)("p",{parentName:"li"},"Example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> _ = {\n...     'west': 'BOUNDARY_FROM_WEST',\n...     'south': 'BOUNDARY_FROM_SOUTH',\n...     'east': 'BOUNDARY_FROM_EAST',\n...     'north': 'BOUNDARY_FROM_NORTH'\n... }\n")))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filters** (*dict*) \u2013 Different filters that may be applied to the output\n\nExample filters:\n\n```\n- max_captured_at\n- min_captured_at\n- image_type: pano, flat, or all\n- org_id\n```\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Output is a GeoJSON string that contains all the filtered sequences within a bbox.\nSequences would NOT be cut at BBox boundary, would select all sequences which are partially\nor entirely in BBox"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  str"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.sequences_in_bbox(\n...     bbox={\n...         'west': 'BOUNDARY_FROM_WEST',\n...         'south': 'BOUNDARY_FROM_SOUTH',\n...         'east': 'BOUNDARY_FROM_EAST',\n...         'north': 'BOUNDARY_FROM_NORTH'\n...     },\n...     max_captured_at='YYYY-MM-DD HH:MM:SS',\n...     min_captured_at='YYYY-MM-DD HH:MM:SS',\n...     image_type='pano',\n...     org_id='ORG_ID'\n... )\n")),(0,i.kt)("h3",{id:"mapillaryinterfaceset_access_tokentoken-str"},"mapillary.interface.set_access_token(token: str)"),(0,i.kt)("p",null,"A function allowing the user to set an access token for the session, which they can create at\n",(0,i.kt)("a",{parentName:"p",href:"https://www.mapillary.com/dashboard/developers"},"https://www.mapillary.com/dashboard/developers"),". Takes token as an argument and sets a global\nvariable used by other functions making API requests. For more information what the details\nof authentication, please check out the blog post at Mapillary.\n",(0,i.kt)("a",{parentName:"p",href:"https://blog.mapillary.com/update/2021/06/23/getting-started-with-the-new-mapillary-api-v4.html"},"https://blog.mapillary.com/update/2021/06/23/getting-started-with-the-new-mapillary-api-v4.html")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"token")," (",(0,i.kt)("em",{parentName:"p"},"str"),") \u2013 The token itself that would\nbe set and accessed globally. Must be obtained"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  None"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  None"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('CLIENT_TOKEN_HERE')\n")),(0,i.kt)("h3",{id:"mapillaryinterfacetraffic_signs_in_bboxbbox-dict-filter_values-list--none-filters-dict"},"mapillary.interface.traffic_signs_in_bbox(bbox: dict, filter_values: list = None, ","*","*","filters: dict)"),(0,i.kt)("p",null,"Extracts traffic signs within a bounding box (bbox)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"bbox")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 bbox coordinates as the argument"),(0,i.kt)("p",{parentName:"li"},"Example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {\n...     'west': 'BOUNDARY_FROM_WEST',\n...     'south': 'BOUNDARY_FROM_SOUTH',\n...     'east': 'BOUNDARY_FROM_EAST',\n...     'north': 'BOUNDARY_FROM_NORTH'\n... }\n")))))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **filter_values** (*list*) \u2013 a list of filter values supported by the API,\n\nExample:\n\n```\n>>> ['regulatory--advisory-maximum-speed-limit--g1', 'regulatory--atvs-permitted--g1']\n```\n\n\n\n* **filters** (*dict*) \u2013 kwarg filters to be applied on the resulted GeoJSON\n\nChronological filters,\n\n\n    * *existed_at*: checks if a feature existed after a certain date depending on the time\n\n    it was first seen at.\n\n\n    * *existed_before*: filters out the features that existed after a given date\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  GeoJSON Object"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  dict"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> import mapillary as mly\n>>> mly.interface.set_access_token('MLY|XXX')\n>>> mly.interface.traffic_signs_in_bbox(\n...    bbox={\n...         'west': 'BOUNDARY_FROM_WEST',\n...         'south': 'BOUNDARY_FROM_SOUTH',\n...         'east': 'BOUNDARY_FROM_EAST',\n...         'north': 'BOUNDARY_FROM_NORTH'\n...    },\n...    filter_values=[\n...        'regulatory--advisory-maximum-speed-limit--g1',\n...        'regulatory--atvs-permitted--g1'\n...    ],\n...    existed_at='YYYY-MM-DD HH:MM:SS',\n...    existed_before='YYYY-MM-DD HH:MM:SS'\n... )\n")),(0,i.kt)("h2",{id:"module-contents"},"Module contents"),(0,i.kt)("h3",{id:"mapillaryinit"},"mapillary.",(0,i.kt)("strong",{parentName:"h3"},"init")),(0,i.kt)("p",null,"This module imports the necessary parts of the SDK"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"License: MIT LICENSE")))}m.isMDXComponent=!0}}]);