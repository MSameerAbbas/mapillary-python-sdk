"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1134],{3905:function(e,t,a){a.d(t,{Zo:function(){return s},kt:function(){return u}});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function p(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},i=Object.keys(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(r=0;r<i.length;r++)a=i[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var m=r.createContext({}),o=function(e){var t=r.useContext(m),a=t;return e&&(a="function"==typeof e?e(t):p(p({},t),e)),a},s=function(e){var t=o(e.components);return r.createElement(m.Provider,{value:t},e.children)},k={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},N=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,i=e.originalType,m=e.parentName,s=l(e,["components","mdxType","originalType","parentName"]),N=o(a),u=n,d=N["".concat(m,".").concat(u)]||N[u]||k[u]||i;return a?r.createElement(d,p(p({ref:t},s),{},{components:a})):r.createElement(d,p({ref:t},s))}));function u(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var i=a.length,p=new Array(i);p[0]=N;var l={};for(var m in t)hasOwnProperty.call(t,m)&&(l[m]=t[m]);l.originalType=e,l.mdxType="string"==typeof e?e:n,p[1]=l;for(var o=2;o<i;o++)p[o]=a[o];return r.createElement.apply(null,p)}return r.createElement.apply(null,a)}N.displayName="MDXCreateElement"},4112:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return l},contentTitle:function(){return m},metadata:function(){return o},toc:function(){return s},default:function(){return N}});var r=a(7462),n=a(3366),i=(a(7294),a(3905)),p=["components"],l={sidebar_position:7},m="mapillary.utils package",o={unversionedId:"sdk/mapillary.utils",id:"sdk/mapillary.utils",isDocsHomePage:!1,title:"mapillary.utils package",description:"## Submodules",source:"@site/docs/sdk/mapillary.utils.md",sourceDirName:"sdk",slug:"/sdk/mapillary.utils",permalink:"/mapillary-python-sdk/docs/sdk/mapillary.utils",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/sdk/mapillary.utils.md",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7},sidebar:"tutorialSidebar",previous:{title:"mapillary.models package",permalink:"/mapillary-python-sdk/docs/sdk/mapillary.models"}},s=[{value:"Submodules",id:"submodules",children:[]},{value:"mapillary.utils.auth module",id:"mapillaryutilsauth-module",children:[{value:"mapillary.utils.auth",id:"mapillaryutilsauth",children:[]}]}],k={toc:s};function N(e){var t=e.components,a=(0,n.Z)(e,p);return(0,i.kt)("wrapper",(0,r.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"mapillaryutils-package"},"mapillary.utils package"),(0,i.kt)("h2",{id:"submodules"},"Submodules"),(0,i.kt)("h2",{id:"mapillaryutilsauth-module"},"mapillary.utils.auth module"),(0,i.kt)("h3",{id:"mapillaryutilsauth"},"mapillary.utils.auth"),(0,i.kt)("p",null," This module contains the authorization logic for the client class of Mapillary, responsible\nfor keeping track of the session token set"),(0,i.kt)("p",null," For more information, please check out ",(0,i.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/"),"."),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsauthauth"},"mapillary.utils.auth.auth()"),(0,i.kt)("p",{parentName:"li"},"Wrap interface functions with logic for Client"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsauthset_tokentoken-str"},"mapillary.utils.auth.set_token(token: str)"),(0,i.kt)("p",{parentName:"li"},"Allows the user to set access token to be able to interact with API v4")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"token")," \u2013 Access token")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"Dictionary containing the access token\n")),(0,i.kt)("h2",{parentName:"li",id:"mapillaryutilsextract-module"},"mapillary.utils.extract module"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsextract"},"mapillary.utils.extract"),(0,i.kt)("p",{parentName:"li"},"This module deals with extracting multiple fields nested within a GeoJSON packet.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsextractextract_propertiesgeojson-dict-properties-list"},"mapillary.utils.extract.extract_properties(geojson: dict, properties: list)"),(0,i.kt)("p",{parentName:"li"},"Extracts specific properties from a complete GeoJSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 GeoJSON object")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"properties")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 A list of properties to extract"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The extracted fields as a dict")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("p",{parentName:"li"},"Usage:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'>>> from utils.extract import extract_properties\n>>> extract_properties(geojson={"type":"FeatureCollection","features":[{"type":"Feature",\n... "geometry":{"type":"Point","coordinates":[-80.12991070747375,25.787652114106322]},\n... "properties":{"captured_at":1540386861135, "compass_angle":252.04260253906,"id":\n... 1274987139570038,"is_pano":\'False\',"sequence_id":"Vf8Iwxx5SemxI7_b_7J5Kw"}},{"type":\n... "Feature","geometry":{"type":"Point","coordinates":[-80.13223886489868,\n... 25.78756517066695]}, "properties":{"captured_at":1422989164000,"compass_angle":\n... 89.781,"id":169629268373019,"is_pano": "True","sequence_id":"dqjuprkOwUnmdEVt5gx-Iw"}}]}\n... , properties=[\'id\']) # id most likely exists\n')),(0,i.kt)("h2",{parentName:"li",id:"mapillaryutilsfilter-module"},"mapillary.utils.filter module"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilter"},"mapillary.utils.filter"),(0,i.kt)("p",{parentName:"li"},"This module contains the filter utilies for high level filtering logic")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterby_look_at_featureimage-dict-look_at_feature-geojsonfeaturefeature"},"mapillary.utils.filter.by_look_at_feature(image: dict, look_at_feature: geojson.feature.Feature)"),(0,i.kt)("p",{parentName:"li"},"Filter through the given image features and return only features with the look_at_feature")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The feature dictionary")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"look_at_feature")," (",(0,i.kt)("em",{parentName:"li"},"A WGS84 GIS feature",(0,i.kt)("strong",{parentName:"em"},", "),"TurfPy"),") \u2013 Feature description"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Whether the given feature is looking at the look_at_features")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"bool\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfiltercompass_angledata-list-angles-tuple--00-3600"},"mapillary.utils.filter.compass_angle(data: list, angles: tuple = (0.0, 360.0))"),(0,i.kt)("p",{parentName:"li"},"Filter out images that do not lie within compass angle range")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The data to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"angles")," \u2013 The compass angle range to filter through"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterexisted_atdata-list-existed_at-str"},"mapillary.utils.filter.existed_at(data: list, existed_at: str)"),(0,i.kt)("p",{parentName:"li"},"Whether the first_seen_at properly existed after a specified time period")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"existed_at")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The UNIX timestamp"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterexisted_beforedata-list-existed_before-str"},"mapillary.utils.filter.existed_before(data: list, existed_before: str)"),(0,i.kt)("p",{parentName:"li"},"Whether the first_seen_at properly existed before a specified time period")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"existed_before")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The UNIX timestamp"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterfeatures_in_bounding_boxdata-list-bbox-dict"},"mapillary.utils.filter.features_in_bounding_box(data: list, bbox: dict)"),(0,i.kt)("p",{parentName:"li"},"Filter for extracting features only in a bounding box")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 the features list to be checked")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"bbox")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 Bounding box coordinates"),(0,i.kt)("p",{parentName:"li"},"Example::"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"```python\n>>> {\n...     'west': 'BOUNDARY_FROM_WEST',\n...     'south': 'BOUNDARY_FROM_SOUTH',\n...     'east': 'BOUNDARY_FROM_EAST',\n...     'north': 'BOUNDARY_FROM_NORTH'\n... }\n```\n"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Features that only exist within the bounding box selected for the given features list\nprovided in the BBox functon")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterfilter_valuesdata-list-values-list-property-str--value"},"mapillary.utils.filter.filter_values(data: list, values: list, property: str = 'value')"),(0,i.kt)("p",{parentName:"li"},"Filter the features based on the existence of a specified value\nin one of the property."),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"TODO"),": Need documentation that lists the \u2018values\u2019, specifically, it refers to \u2018value\u2019\n",(0,i.kt)("em",{parentName:"p"},"TODO"),": under \u2018Detection\u2019, and \u2018Map feature\u2019, related to issue #65")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The data to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"values")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 A list of values to filter by")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"property")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The specific parameter to look into"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterhaversine_distdata-dict-radius-float-coords-list-unit-str--m"},"mapillary.utils.filter.haversine_dist(data: dict, radius: float, coords: list, unit: str = 'm')"),(0,i.kt)("p",{parentName:"li"},"Returns features that are only in the radius specified using the Haversine distance, from\nthe haversine package")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The data to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"radius")," (",(0,i.kt)("em",{parentName:"li"},"float"),") \u2013 Radius for coordinates to fall into")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"coords")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The input coordinates (long, lat)")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"unit")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 Either \u2018ft\u2019, \u2018km\u2019, \u2018m\u2019, \u2018mi\u2019, \u2018nmi\u2019, see here ",(0,i.kt)("a",{parentName:"li",href:"https://pypi.org/project/haversine/"},"https://pypi.org/project/haversine/")))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterhits_by_look_atdata-list-at-dict"},"mapillary.utils.filter.hits_by_look_at(data: list, at: dict)"),(0,i.kt)("p",{parentName:"li"},"Whether the given data have any feature that look at the at coordinates")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 List of features with an Image entity")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"at")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The lng and lat coordinates"),(0,i.kt)("p",{parentName:"li"},"Example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {\n...     'lng': 'longitude',\n...     'lat': 'latitude'\n... }\n"))))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Filtered results of features only looking at at")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterimage_typedata-list-image_type-str"},"mapillary.utils.filter.image_type(data: list, image_type: str)"),(0,i.kt)("p",{parentName:"li"},"The parameter might be \u2018all\u2019 (both is_pano == true and false), \u2018pano\u2019 (is_pano == true only),\nor \u2018flat\u2019 (is_pano == false only)")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The data to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image_type")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 Either \u2018pano\u2019 (True), \u2018flat\u2019 (False), or \u2018all\u2019 (None)"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterin_shapedata-list-boundary"},"mapillary.utils.filter.in_shape(data: list, boundary)"),(0,i.kt)("p",{parentName:"li"},"Whether the given feature list lies within the shape")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 A feature list to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"boundary")," \u2013 Shapely helper for determining existence of point within a boundary"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilteris_looking_atimage_feature-geojsonfeaturefeature-look_at_feature-geojsonfeaturefeature"},"mapillary.utils.filter.is_looking_at(image_feature: geojson.feature.Feature, look_at_feature: geojson.feature.Feature)"),(0,i.kt)("p",{parentName:"li"},"Return whether the image_feature is looking at the look_at_feature")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image_feature")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The feature set of the image")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"look_at_feature")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The feature that is being looked at"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Whether the diff is greater than 310, or less than 50")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"bool\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfiltermax_captured_atdata-list-max_timestamp-str"},"mapillary.utils.filter.max_captured_at(data: list, max_timestamp: str)"),(0,i.kt)("p",{parentName:"li"},"Selects only the feature items that are less\nthan the max_timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"max_timestamp")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The UNIX timestamp as the max time"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Filtered feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("p",{parentName:"li"},"Usage:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> max_captured_at([{'type': 'Feature', 'geometry':\n... {'type': 'Point', 'coordinates': [30.98594605922699, 30.003757307208872]}, 'properties':\n... { ... }, ...}], '2020-05-23')\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfiltermin_captured_atdata-list-min_timestamp-str"},"mapillary.utils.filter.min_captured_at(data: list, min_timestamp: str)"),(0,i.kt)("p",{parentName:"li"},"Selects only the feature items that are less\nthan the min_timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"min_timestamp")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The UNIX timestamp as the max time"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Filtered feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("p",{parentName:"li"},"Usage:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> max_captured_at([{'type': 'Feature', 'geometry':\n... {'type': 'Point', 'coordinates': [30.98594605922699, 30.003757307208872]}, 'properties':\n... { ... }, ...}], '2020-05-23')\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterorganization_iddata-list-organization_ids-list"},"mapillary.utils.filter.organization_id(data: list, organization_ids: list)"),(0,i.kt)("p",{parentName:"li"},"Select only features that contain the specific organization_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The data to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"organization_ids")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The oragnization id(s) to filter through"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterpipelinedata-dict-components-list"},"mapillary.utils.filter.pipeline(data: dict, components: list)"),(0,i.kt)("p",{parentName:"li"},"A pipeline component that helps with making filtering easier. It provides\naccess to different filtering mechanism by simplying letting users\npass in what filter they want to apply, and the arguments for that filter")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The GeoJSON to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"components")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The list of filters to apply"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The filtered feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("p",{parentName:"li"},"Usage:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'>>> # assume variables \'data\', \'kwargs\'\n>>> pipeline(\n...     data=data,\n...     components=[\n...         {"filter": "image_type", "tile": kwargs["image_type"]}\n...         if "image_type" in kwargs\n...         else {},\n...         {"filter": "organization_id", "organization_ids": kwargs["org_id"]}\n...         if "org_id" in kwargs\n...         else {},\n...         {\n...             "filter": "haversine_dist",\n...             "radius": kwargs["radius"],\n...             "coords": [longitude, latitude],\n...         }\n...         if "radius" in kwargs\n...         else 1000\n...     ]\n... )\n')),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfilterpipeline_componentfunc-data-list-exception_message-str-args-list"},"mapillary.utils.filter.pipeline_component(func, data: list, exception_message: str, args: list)"),(0,i.kt)("p",{parentName:"li"},"A pipeline component which is respnonsible for sending functional arguments over\nto the selected target function - throwing a warning in case of an exception")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"func")," (",(0,i.kt)("em",{parentName:"li"},"function"),") \u2013 The filter to apply")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The list of features to filter")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"exception_message")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The exception message to print")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"args")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 Arguments"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The filtered feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("p",{parentName:"li"},"Usage:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> # internally used in mapillary.utils.pipeline\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsfiltersequence_iddata-list-ids-list"},"mapillary.utils.filter.sequence_id(data: list, ids: list)"),(0,i.kt)("p",{parentName:"li"},"Filter out images that do not have the sequence_id in the list of ids")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The data to be filtered")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"ids")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The sequence id(s) to filter through"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h2",{parentName:"li",id:"mapillaryutilsformat-module"},"mapillary.utils.format module"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformat"},"mapillary.utils.format"),(0,i.kt)("p",{parentName:"li"},"This module deals with converting data to and from different file formats.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatdecode_pixel_geometrybase64_string-str-normalized-bool--true-width-int--4096-height-int--4096"},"mapillary.utils.format.decode_pixel_geometry(base64_string: str, normalized: bool = True, width: int = 4096, height: int = 4096)"),(0,i.kt)("p",{parentName:"li"},"Decodes the pixel geometry, and return the coordinates, which can be specified to be\nnormalized")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"base64_string")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The pixel geometry encoded as a vector tile")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"normalized")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 If normalization is required, defaults to True")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"width")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The width of the pixel geometry, defaults to 4096")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"height")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The height of the pixel geometry, defaults to 4096"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A dictionary with coordinates as key, and value as the normalized list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatdecode_pixel_geometry_in_geojsongeojson-uniondict-mapillarymodelsgeojsongeojson-normalized-bool--true-width-int--4096-height-int--4096"},"mapillary.utils.format.decode_pixel_geometry_in_geojson(geojson: Union","[dict, mapillary.models.geojson.GeoJSON]",", normalized: bool = True, width: int = 4096, height: int = 4096)"),(0,i.kt)("p",{parentName:"li"},"Decodes all the pixel_geometry")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"* **geojson** \u2013 The GeoJSON representation to be decoded\n\n\n* **normalized** (*bool*) \u2013 If normalization is required, defaults to True\n\n\n* **width** (*int*) \u2013 The width of the pixel geometry, defaults to 4096\n\n\n* **height** (*int*) \u2013 The height of the pixel geometry, defaults to 4096\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatdetection_features_to_geojsonfeature_list-list"},"mapillary.utils.format.detection_features_to_geojson(feature_list: list)"),(0,i.kt)("p",{parentName:"li"},"Converts a preprocessed list (i.e, features from the detections of either images or\nmap_features from multiple segments) into a fully featured GeoJSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"feature_list")," (",(0,i.kt)("em",{parentName:"p"},"list"),") \u2013 A list of processed features merged from different segments within a\ndetection")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  GeoJSON formatted as expected in a detection format")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("p",{parentName:"li"},"Example:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> # From\n>>> [{'created_at': '2021-05-20T17:49:01+0000', 'geometry':\n... 'GjUKBm1weS1vchIVEgIAABgDIg0JhiekKBoqAABKKQAPGgR0eXBlIgkKB3BvbHlnb24ogCB4AQ==',\n... 'image': {'geometry': {'type': 'Point', 'coordinates': [-97.743279722222,\n... 30.270651388889]}, 'id': '1933525276802129'}, 'value': 'regulatory--no-parking--g2',\n... 'id': '1942105415944115'}, ... ]\n>>> # To\n>>> {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry':\n... {'type': 'Point', 'coordinates': [-97.743279722222, 30.270651388889]}, 'properties': {\n... 'image_id': '1933525276802129', 'created_at': '2021-05-20T17:49:01+0000',\n... 'pixel_geometry':\n... 'GjUKBm1weS1vchIVEgIAABgDIg0JhiekKBoqAABKKQAPGgR0eXBlIgkKB3BvbHlnb24ogCB4AQ==',\n... 'value': 'regulatory--no-parking--g2', 'id': '1942105415944115' } }, ... ]}\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatfeature_to_geojsonjson_data-dict"},"mapillary.utils.format.feature_to_geojson(json_data: dict)"),(0,i.kt)("p",{parentName:"li"},"Converts feature into a GeoJSON, returns output"),(0,i.kt)("p",{parentName:"li"},"From:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {'geometry': {'type': 'Point', 'coordinates': [30.003755665554, 30.985948744314]},\n... 'id':'506566177256016'}\n")),(0,i.kt)("p",{parentName:"li"},"To:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry': {'type':\n... 'Point','coordinates': [30.98594605922699, 30.003757307208872]}, 'properties': {}}]}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"json_data")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The feature as a JSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The formatted GeoJSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatflattendictionarydata-uniondict-collectionsabcmutablemapping-parent_key-str---sep-str--"},"mapillary.utils.format.flatten",(0,i.kt)("em",{parentName:"h3"},"dictionary(data: Union","[dict, collections.abc.MutableMapping]",", parent_key: str = '', sep: str = '"),"')"),(0,i.kt)("p",{parentName:"li"},"Flattens dictionaries"),(0,i.kt)("p",{parentName:"li"},"From:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {'mpy-or': {'extent': 4096, 'version': 2, 'features': [{'geometry': {'type':\n... 'Polygon', 'coordinates': [[[2402, 2776], [2408, 2776]]]}, 'properties': {}, 'id': 1,\n... 'type': 3}]}}\n")),(0,i.kt)("p",{parentName:"li"},"To:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {'mpy-or_extent': 4096, 'mpy-or_version': 2, 'mpy-or_features': [{'geometry':\n... {'type':'Polygon', 'coordinates': [[[2402, 2776], [2408, 2776]]]}, 'properties':\n... {}, 'id': 1,'type': 3}]}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The dictionary itself")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"parent_key")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The root key to start from")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"sep")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The separator"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A flattened dictionary")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatflatten_geojsongeojson-dict"},"mapillary.utils.format.flatten_geojson(geojson: dict)"),(0,i.kt)("p",{parentName:"li"},"Flattens a GeoJSON dictionary to a dictionary with only the relevant keys.\nThis is useful for writing to a CSV file."),(0,i.kt)("p",{parentName:"li"},"Output Structure:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'>>> {\n...     "geometry": {\n...         "type": "Point",\n...         "coordinates": [71.45343, 12.523432]\n...     },\n...     "first_seen_at": "UNIX_TIMESTAMP",\n...     "last_seen_at": "UNIX_TIMESTAMP",\n...     "value": "regulatory--no-parking--g2",\n...     "id": "FEATURE_ID",\n...     "image_id": "IMAGE_ID"\n... }\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"geojson")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The GeoJSON to flatten")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A flattened GeoJSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("p",{parentName:"li"},"Note,"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"1. The geometry key is always present in the output\n\n\n2. The properties are flattened to the following keys:\n\n\n        * \u201cfirst_seen_at\u201d   (optional)\n\n\n        * \u201clast_seen_at\u201d    (optional)\n\n\n        * \u201cvalue\u201d           (optional)\n\n\n        * \u201cid\u201d              (required)\n\n\n        * \u201cimage_id\u201d        (optional)\n\n\n        * etc.\n\n\n3. If the \u2018geometry\\` type is Point, two more properties will be added:\n\n\n        * \u201clongitude\u201d\n\n\n        * \u201clatitude\u201d\n")),(0,i.kt)("p",{parentName:"li"},(0,i.kt)("em",{parentName:"p"},"TODO"),": Further testing needed with different geometries, e.g., Polygon, etc."),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatgeojson_to_features_listjson_data-dict"},"mapillary.utils.format.geojson_to_features_list(json_data: dict)"),(0,i.kt)("p",{parentName:"li"},"Converts a decoded output GeoJSON to a list of feature objects"),(0,i.kt)("p",{parentName:"li"},"The purpose of this formatting utility is to obtain a list of individual features for\ndecoded tiles that can be later extended to the output GeoJSON"),(0,i.kt)("p",{parentName:"li"},"From:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry':\n... {'type': 'Point','coordinates': [30.98594605922699, 30.003757307208872]},\n... 'properties': {}}]}\n")),(0,i.kt)("p",{parentName:"li"},"To:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> [{'type': 'Feature', 'geometry': {'type': 'Point',\n... 'coordinates': [30.98594605922699, 30.003757307208872]}, 'properties': {}}]\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"json_data")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The given json data")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The feature list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatgeojson_to_polygongeojson-dict"},"mapillary.utils.format.geojson_to_polygon(geojson: dict)"),(0,i.kt)("p",{parentName:"li"},"Converts a GeoJSON into a collection of only geometry coordinates for the purpose of\nchecking whether a given coordinate point exists within a shapely polygon"),(0,i.kt)("p",{parentName:"li"},"From:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'>>> {\n...     "type": "FeatureCollection",\n...     "features": [\n...         {\n...             "geometry": {\n...                 "coordinates": [\n...                     -80.13069927692413,\n...                     25.78523699486192\n...                 ],\n...                 "type": "Point"\n...             },\n...             "properties": {\n...                 "first_seen_at": 1422984049000,\n...                 "id": 481978503020355,\n...                 "last_seen_at": 1422984049000,\n...                 "value": "object--street-light"\n...             },\n...             "type": "Feature"\n...         },\n...         {\n...             "geometry": {\n...                 "coordinates": [\n...                     -80.13210475444794,\n...                     25.78362849816017\n...                 ],\n...                 "type": "Point"\n...             },\n...             "properties": {\n...                 "first_seen_at": 1423228306666,\n...                 "id": 252538103315239,\n...                 "last_seen_at": 1423228306666,\n...                 "value": "object--street-light"\n...             },\n...             "type": "Feature"\n...         },\n...         ...\n...     ]\n... }\n')),(0,i.kt)("p",{parentName:"li"},"To:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},'>>> {\n... "type": "FeatureCollection",\n... "features": [\n...         {\n...             "type": "Feature",\n...             "properties": {},\n...             "geometry": {\n...                 "type": "Polygon",\n...                 "coordinates": [\n...                     [\n...                         [\n...                             7.2564697265625,\n...                             43.69716905314008\n...                         ],\n...                         [\n...                             7.27020263671875,\n...                             43.69419030566581\n...                         ],\n...                         ...\n...                     ]\n...                 ]\n...             }\n...         }\n...     ]\n... }\n'))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"geojson")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The input GeoJSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A geojson of the format mentioned under \u2018To\u2019")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatjoin_geojson_with_keysgeojson_src-dict-geojson_src_key-str-geojson_dest-dict-geojson_dest_key-str"},"mapillary.utils.format.join_geojson_with_keys(geojson_src: dict, geojson_src_key: str, geojson_dest: dict, geojson_dest_key: str)"),(0,i.kt)("p",{parentName:"li"},"Combines two GeoJSONS based on the similarity of their specified keys, similar to\nthe SQL join functionality")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson_src")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The starting GeoJSO source")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson_src_key")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The key in properties specified for the GeoJSON source")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson_dest")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The GeoJSON to merge into")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"geojson_dest_key")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The key in properties specified for the GeoJSON to merge into"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The merged GeoJSON")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("p",{parentName:"li"},"Usage:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> join_geojson_with_keys(\n...     geojson_src=geojson_src,\n...     geojson_src_key='id',\n...     geojson_dest=geojson_dest,\n...     geojson_dest_key='id'\n... )\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatmerged_features_list_to_geojsonfeatures_list-list"},"mapillary.utils.format.merged_features_list_to_geojson(features_list: list)"),(0,i.kt)("p",{parentName:"li"},"Converts a processed features list (i.e. a features list with all the needed features merged\nfrom multiple tiles) into a fully-featured GeoJSON"),(0,i.kt)("p",{parentName:"li"},"From:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> [{'type': 'Feature', 'geometry': {'type': 'Point',\n... 'coordinates': [30.98594605922699, 30.003757307208872]}, 'properties': {}}, ...]\n")),(0,i.kt)("p",{parentName:"li"},"To:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> {'type': 'FeatureCollection', 'features': [{'type': 'Feature', 'geometry':\n... {'type': 'Point','coordinates': [30.98594605922699, 30.003757307208872]},\n... 'properties': {}}, ...]}\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"features_list")," (",(0,i.kt)("em",{parentName:"p"},"list"),") \u2013 a list of processed features merged from different tiles within a bbox")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  GeoJSON string formatted with all the extra commas removed.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"str\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsformatnormalize_listcoordinates-list-width-int--4096-height-int--4096"},"mapillary.utils.format.normalize_list(coordinates: list, width: int = 4096, height: int = 4096)"),(0,i.kt)("p",{parentName:"li"},"Normalizes a list of coordinates with the respective width and the height"),(0,i.kt)("p",{parentName:"li"},"From:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> [[[2402, 2776], [2408, 2776]]]\n")),(0,i.kt)("p",{parentName:"li"},"To:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> normalize_list(coordinates)\n... # [[[0.58642578125, 0.677734375], [0.587890625, 0.677734375]]]\n"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"coordinates")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The coordinate list to normalize")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"width")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The width of the coordinates to normalize with, defaults to 4096")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"height")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The height of the coordinates to normalize with, defaults to 4096"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The normalized list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"list\n")),(0,i.kt)("h2",{parentName:"li",id:"mapillaryutilstime-module"},"mapillary.utils.time module"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilstime"},"mapillary.utils.time"),(0,i.kt)("p",{parentName:"li"},"This module contains the time utilies for the UNIX epoch seconds, the time and the date range, and\nthe date filtering logic.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilstimedate_to_unix_timestampdate-str"},"mapillary.utils.time.date_to_unix_timestamp(date: str)"),(0,i.kt)("p",{parentName:"li"},"A utility function that converts the given date\ninto its UNIX epoch timestamp equivalent. It accepts the formats, ranging from\nYYYY-MM-DDTHH:MM:SS, to simply YYYY, and a permutation of the fields in between as well"),(0,i.kt)("p",{parentName:"li"},"Has a special argument, \u2018","*","\u2019, which returns current timestamp")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"date")," (",(0,i.kt)("em",{parentName:"p"},"str"),") \u2013 The date to get the UNIX timestamp epoch of")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The UNIX timestamp equivalent of the input date")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"int\n")),(0,i.kt)("p",{parentName:"li"},"Usage:"),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},">>> from utils.time_utils import date_to_unix_timestamp\n>>> date_to_unix_timestamp('2020-10-23')\n... \"1603393200\"\n")),(0,i.kt)("h2",{parentName:"li",id:"mapillaryutilsverify-module"},"mapillary.utils.verify module"),(0,i.kt)("h3",{parentName:"li",id:"mapillarycontrollerrulesverify"},"mapillary.controller.rules.verify"),(0,i.kt)("p",{parentName:"li"},"This module implements the verification of the filters or keys passed to each of the controllers\nunder ./controllers that implement the business logic functionalities of the Mapillary\nPython SDK."),(0,i.kt)("p",{parentName:"li"},"For more information, please check out ",(0,i.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifycheck_file_name_validityfile_name-str"},"mapillary.utils.verify.check_file_name_validity(file_name: str)"),(0,i.kt)("p",{parentName:"li"},"Checks if the file name is valid"),(0,i.kt)("p",{parentName:"li"},"Valid file names are,")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Without extensions")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Without special characters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"A-Z, a-z, 0-9, _, -")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"file_name")," (",(0,i.kt)("em",{parentName:"p"},"str"),") \u2013 The file name to be checked")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  True if the file name is valid, else False")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"bool\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifyimage_bbox_checkkwargs-dict"},"mapillary.utils.verify.image_bbox_check(kwargs: dict)"),(0,i.kt)("p",{parentName:"li"},"Check if the right arguments have been provided for the image bounding box")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"kwargs")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The dictionary parameters")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A final dictionary with the kwargs")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifyimage_checkkwargs"},"mapillary.utils.verify.image_check(kwargs)"),(0,i.kt)("p",{parentName:"li"},"For image entities, check if the arguments provided fall in the right category")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"**kwargs** (*dict*) \u2013 A dictionary that contains the keyword key-value pair arguments\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifyis_image_ididentity-int-fields-optionallist--none"},"mapillary.utils.verify.is_image_id(identity: int, fields: Optional","[list]"," = None)"),(0,i.kt)("p",{parentName:"li"},"Checks if the id is an image_id")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"identity")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The id to be checked")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"fields")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The fields to be checked"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  True if the id is an image_id, else False")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"bool\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifykwarg_checkkwargs-dict-options-list-callback-str"},"mapillary.utils.verify.kwarg_check(kwargs: dict, options: list, callback: str)"),(0,i.kt)("p",{parentName:"li"},"Checks for keyword arguments amongst the kwarg argument to fall into the options list")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"kwargs")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 A dictionary that contains the keyword key-value pair arguments")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"options")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 A list of possible arguments in kwargs")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"callback")," (",(0,i.kt)("em",{parentName:"li"},"str"),") \u2013 The function that called \u2018kwarg_check\u2019 in the case of an exception"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Raises")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"InvalidOptionError")," \u2013 Invalid option exception")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A boolean, whether the kwargs are appropriate or not")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"bool\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifypoints_traffic_signs_checkkwargs-dict"},"mapillary.utils.verify.points_traffic_signs_check(kwargs: dict)"),(0,i.kt)("p",{parentName:"li"},"Checks for traffic sign arguments")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"kwargs")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The parameters to be passed for filtering")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A dictionary with all the options available specifically")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifyresolution_checkresolution-int"},"mapillary.utils.verify.resolution_check(resolution: int)"),(0,i.kt)("p",{parentName:"li"},"Checking for the proper thumbnail size of the argument")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"resolution")," (",(0,i.kt)("em",{parentName:"p"},"int"),") \u2013 The image size to fetch for")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Raises")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"InvalidOptionError")," \u2013 Invalid thumbnail size passed raises exception")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A check if the size is correct")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"bool\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifysequence_bbox_checkkwargs-dict"},"mapillary.utils.verify.sequence_bbox_check(kwargs: dict)"),(0,i.kt)("p",{parentName:"li"},"Checking of the sequence bounding box")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"kwargs")," (",(0,i.kt)("em",{parentName:"p"},"dict"),") \u2013 The final dictionary with the correct keys")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A dictionary with all the options available specifically")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"dict\n")),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsverifyvalid_ididentity-int-imagetrue"},"mapillary.utils.verify.valid_id(identity: int, image=True)"),(0,i.kt)("p",{parentName:"li"},"Checks if a given id is valid as it is assumed. For example, is a given id expectedly an\nimage_id or not? Is the id expectedly a map_feature_id or not?")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"identity")," (",(0,i.kt)("em",{parentName:"li"},"int"),") \u2013 The ID passed")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image")," (",(0,i.kt)("em",{parentName:"li"},"bool"),") \u2013 Is the passed id an image_id?"))),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Raises")),(0,i.kt)("p",{parentName:"li"},"  ",(0,i.kt)("strong",{parentName:"p"},"InvalidOptionError")," \u2013 Raised when invalid arguments are passed")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  None")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("pre",{parentName:"li"},(0,i.kt)("code",{parentName:"pre"},"None\n")),(0,i.kt)("h2",{parentName:"li",id:"module-contents"},"Module contents"),(0,i.kt)("h3",{parentName:"li",id:"mapillaryutilsinit"},"mapillary.utils.",(0,i.kt)("strong",{parentName:"h3"},"init")),(0,i.kt)("p",{parentName:"li"},"This package contains all the internal utilities used within the Mapillary python SDK.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},"License: MIT LICENSE"))))}N.isMDXComponent=!0}}]);