"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[4673],{3905:(e,t,a)=>{a.d(t,{Zo:()=>s,kt:()=>g});var r=a(7294);function n(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function l(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?l(Object(a),!0).forEach((function(t){n(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):l(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,r,n=function(e,t){if(null==e)return{};var a,r,n={},l=Object.keys(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||(n[a]=e[a]);return n}(e,t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(e);for(r=0;r<l.length;r++)a=l[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(n[a]=e[a])}return n}var p=r.createContext({}),m=function(e){var t=r.useContext(p),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=m(e.components);return r.createElement(p.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},c=r.forwardRef((function(e,t){var a=e.components,n=e.mdxType,l=e.originalType,p=e.parentName,s=o(e,["components","mdxType","originalType","parentName"]),c=m(a),g=n,d=c["".concat(p,".").concat(g)]||c[g]||u[g]||l;return a?r.createElement(d,i(i({ref:t},s),{},{components:a})):r.createElement(d,i({ref:t},s))}));function g(e,t){var a=arguments,n=t&&t.mdxType;if("string"==typeof e||n){var l=a.length,i=new Array(l);i[0]=c;var o={};for(var p in t)hasOwnProperty.call(t,p)&&(o[p]=t[p]);o.originalType=e,o.mdxType="string"==typeof e?e:n,i[1]=o;for(var m=2;m<l;m++)i[m]=a[m];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}c.displayName="MDXCreateElement"},9050:(e,t,a)=>{a.r(t),a.d(t,{contentTitle:()=>i,default:()=>s,frontMatter:()=>l,metadata:()=>o,toc:()=>p});var r=a(7462),n=(a(7294),a(3905));const l={"sidebar position":4},i=void 0,o={unversionedId:"mapillary.controller/mapillary.controller.image",id:"mapillary.controller/mapillary.controller.image",isDocsHomePage:!1,title:"mapillary.controller.image",description:"mapillary.controllers.image",source:"@site/docs/mapillary.controller/mapillary.controller.image.md",sourceDirName:"mapillary.controller",slug:"/mapillary.controller/mapillary.controller.image",permalink:"/mapillary-python-sdk/docs/mapillary.controller/mapillary.controller.image",editUrl:"https://github.com/mapillary/mapillary-python-sdk/tree/main/docs/docs/mapillary.controller/mapillary.controller.image.md",tags:[],version:"current",frontMatter:{"sidebar position":4},sidebar:"tutorialSidebar",previous:{title:"mapillary.controller.feature",permalink:"/mapillary-python-sdk/docs/mapillary.controller/mapillary.controller.feature"},next:{title:"mapillary.controller",permalink:"/mapillary-python-sdk/docs/mapillary.controller/mapillary.controller"}},p=[{value:"mapillary.controllers.image",id:"mapillarycontrollersimage",children:[]},{value:"mapillary.controller.image.geojson_features_controller(geojson: dict, is_image: bool = True, filters: Optionaldict = None)",id:"mapillarycontrollerimagegeojson_features_controllergeojson-dict-is_image-bool--true-filters-optionaldict--none",children:[]},{value:"mapillary.controller.image.get_image_close_to_controller(longitude: float, latitude: float, kwargs: dict)",id:"mapillarycontrollerimageget_image_close_to_controllerlongitude-float-latitude-float-kwargs-dict",children:[]},{value:"mapillary.controller.image.get_image_from_key_controller(key: int, fields: list)",id:"mapillarycontrollerimageget_image_from_key_controllerkey-int-fields-list",children:[]},{value:"mapillary.controller.image.get_image_looking_at_controller(at: Uniondict, Coordinates, list, filters: dict)",id:"mapillarycontrollerimageget_image_looking_at_controllerat-uniondict-coordinates-list-filters-dict",children:[]},{value:"mapillary.controller.image.get_image_thumbnail_controller(image_id: str, resolution: int)",id:"mapillarycontrollerimageget_image_thumbnail_controllerimage_id-str-resolution-int",children:[]},{value:"mapillary.controller.image.get_images_in_bbox_controller(bounding_box: dict, layer: str, zoom: int, filters: dict)",id:"mapillarycontrollerimageget_images_in_bbox_controllerbounding_box-dict-layer-str-zoom-int-filters-dict",children:[]},{value:"mapillary.controller.image.is_image_being_looked_at_controller(at: Uniondict, Coordinates, list, filters: dict)",id:"mapillarycontrollerimageis_image_being_looked_at_controllerat-uniondict-coordinates-list-filters-dict",children:[]},{value:"mapillary.controller.image.shape_features_controller(shape, is_image: bool = True, filters: Optionaldict = None)",id:"mapillarycontrollerimageshape_features_controllershape-is_image-bool--true-filters-optionaldict--none",children:[]}],m={toc:p};function s(e){let{components:t,...a}=e;return(0,n.kt)("wrapper",(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h3",{id:"mapillarycontrollersimage"},"mapillary.controllers.image"),(0,n.kt)("p",null,"This module implements the image filtering and analysis business logic functionalities of the\nMapillary Python SDK."),(0,n.kt)("p",null,"For more information, please check out ",(0,n.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"Copyright: (c) 2021 Facebook")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},"License: MIT LICENSE")),(0,n.kt)("h3",{id:"mapillarycontrollerimagegeojson_features_controllergeojson-dict-is_image-bool--true-filters-optionaldict--none"},"mapillary.controller.image.geojson_features_controller(geojson: dict, is_image: bool = True, filters: Optional","[dict]"," = None)"),(0,n.kt)("p",null,"For extracting images that lie within a GeoJSON and merges the results of the found\nGeoJSON(s) into a single object - by merging all the features into one feature list."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"geojson")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 The geojson to act as the query extent")))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **is_image** (*bool*) \u2013 Is the feature extraction for images? True for images, False for map features\nDefaults to True\n\n\n* **filters** (*dict** (**kwargs**)*) \u2013 Different filters that may be applied to the output, defaults to {}\n\n\n* **filters.zoom** (*int*) \u2013 The zoom level to obtain vector tiles for, defaults to 14\n\n\n* **filters.max_captured_at** (*str*) \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.min_captured_at** (*str*) \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.image_type** (*str*) \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/) under\n\u2018image_type Tiles\u2019 for more information\n\n\n* **filters.compass_angle** (*int*) \u2013 The compass angle of the image\n\n\n* **filters.sequence_id** (*str*) \u2013 ID of the sequence this image belongs to\n\n\n* **filters.organization_id** (*str*) \u2013 ID of the organization this image belongs to. It can be absent\n\n\n* **filters.layer** (*str*) \u2013 The specified image layer, either \u2018overview\u2019, \u2018sequence\u2019, \u2018image\u2019\nif is_image is True, defaults to \u2018image\u2019\n\n\n* **filters.feature_type** (*str*) \u2013 The specified map features, either \u2018point\u2019 or \u2018traffic_signs\u2019\nif is_image is False, defaults to \u2018point\u2019\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Raises")),(0,n.kt)("p",{parentName:"li"},"  ",(0,n.kt)("strong",{parentName:"p"},"InvalidKwargError")," \u2013 Raised when a function is called with the invalid keyword argument(s)\nthat do not belong to the requested API end call"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  A feature collection as a GeoJSON"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  dict"))),(0,n.kt)("h3",{id:"mapillarycontrollerimageget_image_close_to_controllerlongitude-float-latitude-float-kwargs-dict"},"mapillary.controller.image.get_image_close_to_controller(longitude: float, latitude: float, kwargs: dict)"),(0,n.kt)("p",null,"Extracting the GeoJSON for the image data near the ","[longitude, latitude]"," coordinates"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 The kwargs for the filter")))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **longitude** (*float*) \u2013 The longitude\n\n\n* **latitude** (*float*) \u2013 The latitude\n\n\n* **kwargs.zoom** (*int*) \u2013 The zoom level of the tiles to obtain, defaults to 14\n\n\n* **kwargs.min_captured_at** (*str*) \u2013 The minimum date to filter till\n\n\n* **kwargs.max_captured_at** (*str*) \u2013 The maximum date to filter upto\n\n\n* **kwargs.image_type** (*str*) \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019\n\n\n* **kwargs.organization_id** (*str*) \u2013 The organization to retrieve the data for\n\n\n* **kwargs.radius** (*float*) \u2013 The radius that the geometry points will lie in\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  dict"))),(0,n.kt)("h3",{id:"mapillarycontrollerimageget_image_from_key_controllerkey-int-fields-list"},"mapillary.controller.image.get_image_from_key_controller(key: int, fields: list)"),(0,n.kt)("p",null,"A controller for getting properties of a certain image given the image key and\nthe list of fields/properties to be returned"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"key")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 The image key")))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **fields** (*list*) \u2013 The list of fields to be returned\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  The requested image properties in GeoJSON format"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  str"))),(0,n.kt)("h3",{id:"mapillarycontrollerimageget_image_looking_at_controllerat-uniondict-coordinates-list-filters-dict"},"mapillary.controller.image.get_image_looking_at_controller(at: Union","[dict, Coordinates, list]",", filters: dict)"),(0,n.kt)("p",null,"Checks if the image with coordinates \u2018at\u2019 is looked with the given filters."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 Filters to pass the data through")))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **at** (*dict*) \u2013 The dict of coordinates of the position of the looking at\ncoordinates. Format:\n\n```\n>>> {\n>>>     'lng': 'longitude',\n>>>     'lat': 'latitude'\n>>> }\n```\n\n\n\n* **filters.zoom** (*int*) \u2013 The zoom level of the tiles to obtain, defaults to 14\n\n\n* **filters.min_captured_at** (*str*) \u2013 The minimum date to filter till\n\n\n* **filters.max_captured_at** (*str*) \u2013 The maximum date to filter upto\n\n\n* **filters.radius** (*float*) \u2013 The radius that the geometry points will lie in\n\n\n* **filters.image_type** (*str*) \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019\n\n\n* **filters.organization_id** (*str*) \u2013 The organization to retrieve the data for\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  dict"))),(0,n.kt)("h3",{id:"mapillarycontrollerimageget_image_thumbnail_controllerimage_id-str-resolution-int"},"mapillary.controller.image.get_image_thumbnail_controller(image_id: str, resolution: int)"),(0,n.kt)("p",null,"This controller holds the business logic for retrieving\nan image thumbnail with a specific resolution (256, 1024, or 2048)\nusing an image ID/key"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"image_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 Image key as the argument")))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **resolution** (*int*) \u2013 Option for the thumbnail size, with available resolutions:\n256, 1024, and 2048\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  A URL for the thumbnail"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  str"))),(0,n.kt)("h3",{id:"mapillarycontrollerimageget_images_in_bbox_controllerbounding_box-dict-layer-str-zoom-int-filters-dict"},"mapillary.controller.image.get_images_in_bbox_controller(bounding_box: dict, layer: str, zoom: int, filters: dict)"),(0,n.kt)("p",null,"For getting a complete list of images that lie within a bounding box,\nthat can be filtered via the filters argument"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"bounding_box")," (",(0,n.kt)("em",{parentName:"p"},"dict"),") \u2013 A bounding box representation\nExample:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},">>> {\n...     'west': 'BOUNDARY_FROM_WEST',\n...     'south': 'BOUNDARY_FROM_SOUTH',\n...     'east': 'BOUNDARY_FROM_EAST',\n...     'north': 'BOUNDARY_FROM_NORTH'\n... }\n")))))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **zoom** \u2013 The zoom level\n\n\n* **zoom** \u2013 int\n\n\n* **layer** (*str*) \u2013 Either \u2018image\u2019, \u2018sequence\u2019, \u2018overview\u2019\n\n\n* **filters** (*dict*) \u2013 Filters to pass the data through\n\n\n* **filters.max_captured_at** (*str*) \u2013 The max date that can be filtered upto\n\n\n* **filters.min_captured_at** (*str*) \u2013 The min date that can be filtered from\n\n\n* **filters.image_type** (*str*) \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019\n\n\n* **filters.compass_angle** (*float*) \u2013 \n\n\n* **filters.organization_id** (*int*) \u2013 \n\n\n* **filters.sequence_id** (*str*) \u2013 \n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Raises")),(0,n.kt)("p",{parentName:"li"},"  ",(0,n.kt)("strong",{parentName:"p"},"InvalidKwargError")," \u2013 Raised when a function is called with the invalid keyword argument(s)\nthat do not belong to the requested API end call"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  str"))),(0,n.kt)("p",null,"Reference,"),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("a",{parentName:"li",href:"https://www.mapillary.com/developer/api-documentation/#coverage-tiles"},"https://www.mapillary.com/developer/api-documentation/#coverage-tiles"))),(0,n.kt)("h3",{id:"mapillarycontrollerimageis_image_being_looked_at_controllerat-uniondict-coordinates-list-filters-dict"},"mapillary.controller.image.is_image_being_looked_at_controller(at: Union","[dict, Coordinates, list]",", filters: dict)"),(0,n.kt)("p",null,"Checks if the image with coordinates \u2018at\u2019 is looked with the given filters."),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"at")," (",(0,n.kt)("em",{parentName:"p"},"Union",(0,n.kt)("strong",{parentName:"em"},"["),"dict",(0,n.kt)("strong",{parentName:"em"},", "),"mapillary.models.geojson.Coordinates",(0,n.kt)("strong",{parentName:"em"},", "),"list**]"),") \u2013 The dict of coordinates of the position of the looking at coordinates. Format:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},">>> at_dict = {\n...     'lng': 'longitude',\n...     'lat': 'latitude'\n... }\n>>> at_list = [12.954940544167, 48.0537894275]\n>>> from mapillary.models.geojson import Coordinates\n>>> at_coord: Coordinates = Coordinates(lng=12.954940544167, lat=48.0537894275)\n")))))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **filters.zoom** \u2013 The zoom level of the tiles to obtain, defaults to 14\n\n\n* **filters.min_captured_at** (*str*) \u2013 The minimum date to filter till\n\n\n* **filters.max_captured_at** (*str*) \u2013 The maximum date to filter upto\n\n\n* **filters.radius** (*float*) \u2013 The radius that the geometry points will lie in\n\n\n* **filters.image_type** (*str*) \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019\n\n\n* **filters.organization_id** (*str*) \u2013 The organization to retrieve the data for\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  True if the image is looked at by the given looker and at coordinates, False otherwise"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  bool"))),(0,n.kt)("h3",{id:"mapillarycontrollerimageshape_features_controllershape-is_image-bool--true-filters-optionaldict--none"},"mapillary.controller.image.shape_features_controller(shape, is_image: bool = True, filters: Optional","[dict]"," = None)"),(0,n.kt)("p",null,"For extracting images that lie within a shape, merging the results of the found features\ninto a single object - by merging all the features into one list in a feature collection."),(0,n.kt)("p",null,"The shape format is as follows:"),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},'>>> {\n...     "type": "FeatureCollection",\n...     "features": [\n...         {\n...             "type": "Feature",\n...             "properties": {},\n...             "geometry": {\n...                 "type": "Polygon",\n...                 "coordinates": [\n...                     [\n...                        [\n...                              7.2564697265625,\n...                             43.69716905314008\n...                         ],\n...                         ...\n...                     ]\n...                 ]\n...             }\n...         }\n...     ]\n... }\n')),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"shape")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 A shape that describes features, formatted as a geojson")))),(0,n.kt)("pre",null,(0,n.kt)("code",{parentName:"pre"},"* **is_image** (*bool*) \u2013 Is the feature extraction for images? True for images, False for map features\nDefaults to True\n\n\n* **filters** (*dict** (**kwargs**)*) \u2013 Different filters that may be applied to the output, defaults to {}\n\n\n* **filters.max_captured_at** (*str*) \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.min_captured_at** (*str*) \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019\n\n\n* **filters.image_type** (*str*) \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See [https://www.mapillary.com/developer/api-documentation/](https://www.mapillary.com/developer/api-documentation/) under\n\u2018image_type Tiles\u2019 for more information\n\n\n* **filters.compass_angle** (*int*) \u2013 The compass angle of the image\n\n\n* **filters.sequence_id** (*str*) \u2013 ID of the sequence this image belongs to\n\n\n* **filters.organization_id** (*str*) \u2013 ID of the organization this image belongs to. It can be absent\n\n\n* **filters.layer** (*str*) \u2013 The specified image layer, either \u2018overview\u2019, \u2018sequence\u2019, \u2018image\u2019\nif is_image is True, defaults to \u2018image\u2019\n\n\n* **filters.feature_type** (*str*) \u2013 The specified map features, either \u2018point\u2019 or \u2018traffic_signs\u2019\nif is_image is False, defaults to \u2018point\u2019\n")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Raises")),(0,n.kt)("p",{parentName:"li"},"  ",(0,n.kt)("strong",{parentName:"p"},"InvalidKwargError")," \u2013 Raised when a function is called with the invalid keyword argument(s)\nthat do not belong to the requested API end call"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  A feature collection as a GeoJSON"))),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("p",{parentName:"li"},"  dict"))))}s.isMDXComponent=!0}}]);