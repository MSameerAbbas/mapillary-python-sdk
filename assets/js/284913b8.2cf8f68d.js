"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1583],{3905:function(t,e,a){a.d(e,{Zo:function(){return m},kt:function(){return d}});var l=a(7294);function r(t,e,a){return e in t?Object.defineProperty(t,e,{value:a,enumerable:!0,configurable:!0,writable:!0}):t[e]=a,t}function i(t,e){var a=Object.keys(t);if(Object.getOwnPropertySymbols){var l=Object.getOwnPropertySymbols(t);e&&(l=l.filter((function(e){return Object.getOwnPropertyDescriptor(t,e).enumerable}))),a.push.apply(a,l)}return a}function n(t){for(var e=1;e<arguments.length;e++){var a=null!=arguments[e]?arguments[e]:{};e%2?i(Object(a),!0).forEach((function(e){r(t,e,a[e])})):Object.getOwnPropertyDescriptors?Object.defineProperties(t,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(e){Object.defineProperty(t,e,Object.getOwnPropertyDescriptor(a,e))}))}return t}function p(t,e){if(null==t)return{};var a,l,r=function(t,e){if(null==t)return{};var a,l,r={},i=Object.keys(t);for(l=0;l<i.length;l++)a=i[l],e.indexOf(a)>=0||(r[a]=t[a]);return r}(t,e);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(t);for(l=0;l<i.length;l++)a=i[l],e.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(t,a)&&(r[a]=t[a])}return r}var s=l.createContext({}),u=function(t){var e=l.useContext(s),a=e;return t&&(a="function"==typeof t?t(e):n(n({},e),t)),a},m=function(t){var e=u(t.components);return l.createElement(s.Provider,{value:e},t.children)},o={inlineCode:"code",wrapper:function(t){var e=t.children;return l.createElement(l.Fragment,{},e)}},k=l.forwardRef((function(t,e){var a=t.components,r=t.mdxType,i=t.originalType,s=t.parentName,m=p(t,["components","mdxType","originalType","parentName"]),k=u(a),d=r,f=k["".concat(s,".").concat(d)]||k[d]||o[d]||i;return a?l.createElement(f,n(n({ref:e},m),{},{components:a})):l.createElement(f,n({ref:e},m))}));function d(t,e){var a=arguments,r=e&&e.mdxType;if("string"==typeof t||r){var i=a.length,n=new Array(i);n[0]=k;var p={};for(var s in e)hasOwnProperty.call(e,s)&&(p[s]=e[s]);p.originalType=t,p.mdxType="string"==typeof t?t:r,n[1]=p;for(var u=2;u<i;u++)n[u]=a[u];return l.createElement.apply(null,n)}return l.createElement.apply(null,a)}k.displayName="MDXCreateElement"},1261:function(t,e,a){a.r(e),a.d(e,{frontMatter:function(){return p},contentTitle:function(){return s},metadata:function(){return u},toc:function(){return m},default:function(){return k}});var l=a(7462),r=a(3366),i=(a(7294),a(3905)),n=["components"],p={"sidebar position":4},s=void 0,u={unversionedId:"mapillary.utils/mapillary.utils.filter",id:"mapillary.utils/mapillary.utils.filter",isDocsHomePage:!1,title:"mapillary.utils.filter",description:"mapillary.utils.filter",source:"@site/docs/mapillary.utils/mapillary.utils.filter.md",sourceDirName:"mapillary.utils",slug:"/mapillary.utils/mapillary.utils.filter",permalink:"/mapillary-python-sdk/docs/mapillary.utils/mapillary.utils.filter",editUrl:"https://github.com/mapillary/mapillary-python-sdk/tree/main/docs/docs/mapillary.utils/mapillary.utils.filter.md",tags:[],version:"current",frontMatter:{"sidebar position":4},sidebar:"tutorialSidebar",previous:{title:"mapillary.utils.extract",permalink:"/mapillary-python-sdk/docs/mapillary.utils/mapillary.utils.extract"},next:{title:"mapillary.utils.format",permalink:"/mapillary-python-sdk/docs/mapillary.utils/mapillary.utils.format"}},m=[{value:"mapillary.utils.filter",id:"mapillaryutilsfilter",children:[]},{value:"mapillary.utils.filter.by_look_at_feature(image: dict, look_at_feature: geojson.feature.Feature)",id:"mapillaryutilsfilterby_look_at_featureimage-dict-look_at_feature-geojsonfeaturefeature",children:[]},{value:"mapillary.utils.filter.compass_angle(data: list, angles: tuple = (0.0, 360.0))",id:"mapillaryutilsfiltercompass_angledata-list-angles-tuple--00-3600",children:[]},{value:"mapillary.utils.filter.existed_at(data: list, existed_at: str)",id:"mapillaryutilsfilterexisted_atdata-list-existed_at-str",children:[]},{value:"mapillary.utils.filter.existed_before(data: list, existed_before: str)",id:"mapillaryutilsfilterexisted_beforedata-list-existed_before-str",children:[]},{value:"mapillary.utils.filter.features_in_bounding_box(data: list, bbox: dict)",id:"mapillaryutilsfilterfeatures_in_bounding_boxdata-list-bbox-dict",children:[]},{value:"mapillary.utils.filter.filter_values(data: list, values: list, property: str = &#39;value&#39;)",id:"mapillaryutilsfilterfilter_valuesdata-list-values-list-property-str--value",children:[]},{value:"mapillary.utils.filter.haversine_dist(data: dict, radius: float, coords: list, unit: str = &#39;m&#39;)",id:"mapillaryutilsfilterhaversine_distdata-dict-radius-float-coords-list-unit-str--m",children:[]},{value:"mapillary.utils.filter.hits_by_look_at(data: list, at: dict)",id:"mapillaryutilsfilterhits_by_look_atdata-list-at-dict",children:[]},{value:"mapillary.utils.filter.image_type(data: list, image_type: str)",id:"mapillaryutilsfilterimage_typedata-list-image_type-str",children:[]},{value:"mapillary.utils.filter.in_shape(data: list, boundary)",id:"mapillaryutilsfilterin_shapedata-list-boundary",children:[]},{value:"mapillary.utils.filter.is_looking_at(image_feature: geojson.feature.Feature, look_at_feature: geojson.feature.Feature)",id:"mapillaryutilsfilteris_looking_atimage_feature-geojsonfeaturefeature-look_at_feature-geojsonfeaturefeature",children:[]},{value:"mapillary.utils.filter.max_captured_at(data: list, max_timestamp: str)",id:"mapillaryutilsfiltermax_captured_atdata-list-max_timestamp-str",children:[]},{value:"mapillary.utils.filter.min_captured_at(data: list, min_timestamp: str)",id:"mapillaryutilsfiltermin_captured_atdata-list-min_timestamp-str",children:[]},{value:"mapillary.utils.filter.organization_id(data: list, organization_ids: list)",id:"mapillaryutilsfilterorganization_iddata-list-organization_ids-list",children:[]},{value:"mapillary.utils.filter.pipeline(data: dict, components: list)",id:"mapillaryutilsfilterpipelinedata-dict-components-list",children:[]},{value:"mapillary.utils.filter.pipeline_component(func, data: list, exception_message: str, args: list)",id:"mapillaryutilsfilterpipeline_componentfunc-data-list-exception_message-str-args-list",children:[]},{value:"mapillary.utils.filter.sequence_id(data: list, ids: list)",id:"mapillaryutilsfiltersequence_iddata-list-ids-list",children:[]}],o={toc:m};function k(t){var e=t.components,a=(0,r.Z)(t,n);return(0,i.kt)("wrapper",(0,l.Z)({},o,a,{components:e,mdxType:"MDXLayout"}),(0,i.kt)("h3",{id:"mapillaryutilsfilter"},"mapillary.utils.filter"),(0,i.kt)("p",null,"This module contains the filter utilies for high level filtering logic"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Copyright: (c) 2021 Facebook")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"License: MIT LICENSE")),(0,i.kt)("h3",{id:"mapillaryutilsfilterby_look_at_featureimage-dict-look_at_feature-geojsonfeaturefeature"},"mapillary.utils.filter.by_look_at_feature(image: dict, look_at_feature: geojson.feature.Feature)"),(0,i.kt)("p",null,"Filter through the given image features and return only features with the look_at_feature"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The feature dictionary")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **look_at_feature** (*A WGS84 GIS feature**, **TurfPy*) \u2013 Feature description\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Whether the given feature is looking at the look_at_features"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  bool"))),(0,i.kt)("h3",{id:"mapillaryutilsfiltercompass_angledata-list-angles-tuple--00-3600"},"mapillary.utils.filter.compass_angle(data: list, angles: tuple = (0.0, 360.0))"),(0,i.kt)("p",null,"Filter out images that do not lie within compass angle range"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The data to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **angles** \u2013 The compass angle range to filter through\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterexisted_atdata-list-existed_at-str"},"mapillary.utils.filter.existed_at(data: list, existed_at: str)"),(0,i.kt)("p",null,"Whether the first_seen_at properly existed after a specified time period"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **existed_at** (*str*) \u2013 The UNIX timestamp\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterexisted_beforedata-list-existed_before-str"},"mapillary.utils.filter.existed_before(data: list, existed_before: str)"),(0,i.kt)("p",null,"Whether the first_seen_at properly existed before a specified time period"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **existed_before** (*str*) \u2013 The UNIX timestamp\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterfeatures_in_bounding_boxdata-list-bbox-dict"},"mapillary.utils.filter.features_in_bounding_box(data: list, bbox: dict)"),(0,i.kt)("p",null,"Filter for extracting features only in a bounding box"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 the features list to be checked")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **bbox** (*dict*) \u2013 Bounding box coordinates\n\nExample::\n\n    ```python\n    >>> {\n    ...     'west': 'BOUNDARY_FROM_WEST',\n    ...     'south': 'BOUNDARY_FROM_SOUTH',\n    ...     'east': 'BOUNDARY_FROM_EAST',\n    ...     'north': 'BOUNDARY_FROM_NORTH'\n    ... }\n    ```\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Features that only exist within the bounding box selected for the given features list\nprovided in the BBox functon"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterfilter_valuesdata-list-values-list-property-str--value"},"mapillary.utils.filter.filter_values(data: list, values: list, property: str = 'value')"),(0,i.kt)("p",null,"Filter the features based on the existence of a specified value\nin one of the property."),(0,i.kt)("p",null,(0,i.kt)("em",{parentName:"p"},"TODO"),": Need documentation that lists the \u2018values\u2019, specifically, it refers to \u2018value\u2019\n",(0,i.kt)("em",{parentName:"p"},"TODO"),": under \u2018Detection\u2019, and \u2018Map feature\u2019, related to issue #65"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The data to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **values** (*list*) \u2013 A list of values to filter by\n\n\n* **property** (*str*) \u2013 The specific parameter to look into\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  dict"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterhaversine_distdata-dict-radius-float-coords-list-unit-str--m"},"mapillary.utils.filter.haversine_dist(data: dict, radius: float, coords: list, unit: str = 'm')"),(0,i.kt)("p",null,"Returns features that are only in the radius specified using the Haversine distance, from\nthe haversine package"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The data to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **radius** (*float*) \u2013 Radius for coordinates to fall into\n\n\n* **coords** (*list*) \u2013 The input coordinates (long, lat)\n\n\n* **unit** (*str*) \u2013 Either \u2018ft\u2019, \u2018km\u2019, \u2018m\u2019, \u2018mi\u2019, \u2018nmi\u2019, see here [https://pypi.org/project/haversine/](https://pypi.org/project/haversine/)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterhits_by_look_atdata-list-at-dict"},"mapillary.utils.filter.hits_by_look_at(data: list, at: dict)"),(0,i.kt)("p",null,"Whether the given data have any feature that look at the at coordinates"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 List of features with an Image entity")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **at** (*dict*) \u2013 The lng and lat coordinates\n\nExample:\n\n```\n>>> {\n...     'lng': 'longitude',\n...     'lat': 'latitude'\n... }\n```\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Filtered results of features only looking at at"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterimage_typedata-list-image_type-str"},"mapillary.utils.filter.image_type(data: list, image_type: str)"),(0,i.kt)("p",null,"The parameter might be \u2018all\u2019 (both is_pano == true and false), \u2018pano\u2019 (is_pano == true only),\nor \u2018flat\u2019 (is_pano == false only)"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The data to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **image_type** (*str*) \u2013 Either \u2018pano\u2019 (True), \u2018flat\u2019 (False), or \u2018all\u2019 (None)\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterin_shapedata-list-boundary"},"mapillary.utils.filter.in_shape(data: list, boundary)"),(0,i.kt)("p",null,"Whether the given feature list lies within the shape"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 A feature list to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **boundary** \u2013 Shapely helper for determining existence of point within a boundary\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("h3",{id:"mapillaryutilsfilteris_looking_atimage_feature-geojsonfeaturefeature-look_at_feature-geojsonfeaturefeature"},"mapillary.utils.filter.is_looking_at(image_feature: geojson.feature.Feature, look_at_feature: geojson.feature.Feature)"),(0,i.kt)("p",null,"Return whether the image_feature is looking at the look_at_feature"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"image_feature")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The feature set of the image")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **look_at_feature** (*dict*) \u2013 The feature that is being looked at\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Whether the diff is greater than 310, or less than 50"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  bool"))),(0,i.kt)("h3",{id:"mapillaryutilsfiltermax_captured_atdata-list-max_timestamp-str"},"mapillary.utils.filter.max_captured_at(data: list, max_timestamp: str)"),(0,i.kt)("p",null,"Selects only the feature items that are less\nthan the max_timestamp"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **max_timestamp** (*str*) \u2013 The UNIX timestamp as the max time\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Filtered feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> max_captured_at([{'type': 'Feature', 'geometry':\n... {'type': 'Point', 'coordinates': [30.98594605922699, 30.003757307208872]}, 'properties':\n... { ... }, ...}], '2020-05-23')\n")),(0,i.kt)("h3",{id:"mapillaryutilsfiltermin_captured_atdata-list-min_timestamp-str"},"mapillary.utils.filter.min_captured_at(data: list, min_timestamp: str)"),(0,i.kt)("p",null,"Selects only the feature items that are less\nthan the min_timestamp"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The feature list")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **min_timestamp** (*str*) \u2013 The UNIX timestamp as the max time\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  Filtered feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> max_captured_at([{'type': 'Feature', 'geometry':\n... {'type': 'Point', 'coordinates': [30.98594605922699, 30.003757307208872]}, 'properties':\n... { ... }, ...}], '2020-05-23')\n")),(0,i.kt)("h3",{id:"mapillaryutilsfilterorganization_iddata-list-organization_ids-list"},"mapillary.utils.filter.organization_id(data: list, organization_ids: list)"),(0,i.kt)("p",null,"Select only features that contain the specific organization_id"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The data to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **organization_ids** (*list*) \u2013 The oragnization id(s) to filter through\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  dict"))),(0,i.kt)("h3",{id:"mapillaryutilsfilterpipelinedata-dict-components-list"},"mapillary.utils.filter.pipeline(data: dict, components: list)"),(0,i.kt)("p",null,"A pipeline component that helps with making filtering easier. It provides\naccess to different filtering mechanism by simplying letting users\npass in what filter they want to apply, and the arguments for that filter"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"dict"),") \u2013 The GeoJSON to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **components** (*list*) \u2013 The list of filters to apply\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The filtered feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},'>>> # assume variables \'data\', \'kwargs\'\n>>> pipeline(\n...     data=data,\n...     components=[\n...         {"filter": "image_type", "tile": kwargs["image_type"]}\n...         if "image_type" in kwargs\n...         else {},\n...         {"filter": "organization_id", "organization_ids": kwargs["org_id"]}\n...         if "org_id" in kwargs\n...         else {},\n...         {\n...             "filter": "haversine_dist",\n...             "radius": kwargs["radius"],\n...             "coords": [longitude, latitude],\n...         }\n...         if "radius" in kwargs\n...         else 1000\n...     ]\n... )\n')),(0,i.kt)("h3",{id:"mapillaryutilsfilterpipeline_componentfunc-data-list-exception_message-str-args-list"},"mapillary.utils.filter.pipeline_component(func, data: list, exception_message: str, args: list)"),(0,i.kt)("p",null,"A pipeline component which is respnonsible for sending functional arguments over\nto the selected target function - throwing a warning in case of an exception"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"func")," (",(0,i.kt)("em",{parentName:"li"},"function"),") \u2013 The filter to apply")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **data** (*list*) \u2013 The list of features to filter\n\n\n* **exception_message** (*str*) \u2013 The exception message to print\n\n\n* **args** (*list*) \u2013 Arguments\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  The filtered feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))),(0,i.kt)("p",null,"Usage:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},">>> # internally used in mapillary.utils.pipeline\n")),(0,i.kt)("h3",{id:"mapillaryutilsfiltersequence_iddata-list-ids-list"},"mapillary.utils.filter.sequence_id(data: list, ids: list)"),(0,i.kt)("p",null,"Filter out images that do not have the sequence_id in the list of ids"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Parameters")),(0,i.kt)("ul",{parentName:"li"},(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("strong",{parentName:"li"},"data")," (",(0,i.kt)("em",{parentName:"li"},"list"),") \u2013 The data to be filtered")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre"},"* **ids** (*list*) \u2013 The sequence id(s) to filter through\n")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Returns")),(0,i.kt)("p",{parentName:"li"},"  A feature list"))),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("strong",{parentName:"p"},"Return type")),(0,i.kt)("p",{parentName:"li"},"  list"))))}k.isMDXComponent=!0}}]);