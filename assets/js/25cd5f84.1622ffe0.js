"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3122],{3905:function(e,t,a){a.d(t,{Zo:function(){return s},kt:function(){return u}});var r=a(7294);function l(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function i(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){l(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function p(e,t){if(null==e)return{};var a,r,l=function(e,t){if(null==e)return{};var a,r,l={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(l[a]=e[a]);return l}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(l[a]=e[a])}return l}var o=r.createContext({}),m=function(e){var t=r.useContext(o),a=t;return e&&(a="function"==typeof e?e(t):i(i({},t),e)),a},s=function(e){var t=m(e.components);return r.createElement(o.Provider,{value:t},e.children)},k={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},N=r.forwardRef((function(e,t){var a=e.components,l=e.mdxType,n=e.originalType,o=e.parentName,s=p(e,["components","mdxType","originalType","parentName"]),N=m(a),u=l,c=N["".concat(o,".").concat(u)]||N[u]||k[u]||n;return a?r.createElement(c,i(i({ref:t},s),{},{components:a})):r.createElement(c,i({ref:t},s))}));function u(e,t){var a=arguments,l=t&&t.mdxType;if("string"==typeof e||l){var n=a.length,i=new Array(n);i[0]=N;var p={};for(var o in t)hasOwnProperty.call(t,o)&&(p[o]=t[o]);p.originalType=e,p.mdxType="string"==typeof e?e:l,i[1]=p;for(var m=2;m<n;m++)i[m]=a[m];return r.createElement.apply(null,i)}return r.createElement.apply(null,a)}N.displayName="MDXCreateElement"},3083:function(e,t,a){a.r(t),a.d(t,{frontMatter:function(){return p},contentTitle:function(){return o},metadata:function(){return m},toc:function(){return s},default:function(){return N}});var r=a(7462),l=a(3366),n=(a(7294),a(3905)),i=["components"],p={sidebar_position:3},o="mapillary.controller package",m={unversionedId:"sdk/mapillary.controller",id:"sdk/mapillary.controller",isDocsHomePage:!1,title:"mapillary.controller package",description:"## Submodules",source:"@site/docs/sdk/mapillary.controller.md",sourceDirName:"sdk",slug:"/sdk/mapillary.controller",permalink:"/mapillary-python-sdk/docs/sdk/mapillary.controller",editUrl:"https://github.com/facebook/docusaurus/edit/main/website/docs/sdk/mapillary.controller.md",tags:[],version:"current",sidebarPosition:3,frontMatter:{sidebar_position:3},sidebar:"tutorialSidebar",previous:{title:"mapillary.config package",permalink:"/mapillary-python-sdk/docs/sdk/mapillary.config"},next:{title:"mapillary package",permalink:"/mapillary-python-sdk/docs/sdk/mapillary"}},s=[{value:"Submodules",id:"submodules",children:[]},{value:"mapillary.controller.detection module",id:"mapillarycontrollerdetection-module",children:[{value:"mapillary.controllers.detection",id:"mapillarycontrollersdetection",children:[]}]}],k={toc:s};function N(e){var t=e.components,a=(0,l.Z)(e,i);return(0,n.kt)("wrapper",(0,r.Z)({},k,a,{components:t,mdxType:"MDXLayout"}),(0,n.kt)("h1",{id:"mapillarycontroller-package"},"mapillary.controller package"),(0,n.kt)("h2",{id:"submodules"},"Submodules"),(0,n.kt)("h2",{id:"mapillarycontrollerdetection-module"},"mapillary.controller.detection module"),(0,n.kt)("h3",{id:"mapillarycontrollersdetection"},"mapillary.controllers.detection"),(0,n.kt)("p",null," This module implements the detection based business logic functionalities of the Mapillary\nPython SDK."),(0,n.kt)("p",null," For more information, please check out ",(0,n.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/")),(0,n.kt)("ul",null,(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerdetectionget_image_detections_controllerimage_id-unionstr-int-fields-optionallist--none"},"mapillary.controller.detection.get_image_detections_controller(image_id: Union","[str, int]",", fields: Optional","[list]"," = None)"),(0,n.kt)("p",{parentName:"li"},"Get image detections with given (image) key")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"image_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The image id")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"fields")," (",(0,n.kt)("em",{parentName:"li"},"list"),") \u2013 The fields possible for the detection endpoint. Please see\n",(0,n.kt)("a",{parentName:"li",href:"https://www.mapillary.com/developer/api-documentation"},"https://www.mapillary.com/developer/api-documentation")," for more information"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"dict\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerdetectionget_map_feature_detections_controllermap_feature_id-unionstr-int-fields-optionallist--none"},"mapillary.controller.detection.get_map_feature_detections_controller(map_feature_id: Union","[str, int]",", fields: Optional","[list]"," = None)"),(0,n.kt)("p",{parentName:"li"},"Get image detections with given (map feature) key")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"map_feature_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The map feature id")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"fields")," (",(0,n.kt)("em",{parentName:"li"},"list"),") \u2013 The fields possible for the detection endpoint. Please see\n",(0,n.kt)("a",{parentName:"li",href:"https://www.mapillary.com/developer/api-documentation"},"https://www.mapillary.com/developer/api-documentation")," for more information"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"dict\n")),(0,n.kt)("h2",{parentName:"li",id:"mapillarycontrollerfeature-module"},"mapillary.controller.feature module"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollersfeature"},"mapillary.controllers.feature"),(0,n.kt)("p",{parentName:"li"},"This module implements the feature extraction business logic functionalities of the Mapillary\nPython SDK."),(0,n.kt)("p",{parentName:"li"},"For more information, please check out ",(0,n.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerfeatureget_feature_from_key_controllerkey-int-fields-list"},"mapillary.controller.feature.get_feature_from_key_controller(key: int, fields: list)"),(0,n.kt)("p",{parentName:"li"},"A controller for getting properties of a certain image given the image key and\nthe list of fields/properties to be returned")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"key")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 The image key")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"fields")," (",(0,n.kt)("em",{parentName:"li"},"list"),") \u2013 List of possible fields"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  The requested feature properties in GeoJSON format")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"str\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerfeatureget_map_features_in_bbox_controllerbbox-dict-filter_values-list-filters-dict-layer-str--points"},"mapillary.controller.feature.get_map_features_in_bbox_controller(bbox: dict, filter_values: list, filters: dict, layer: str = 'points')"),(0,n.kt)("p",{parentName:"li"},"For extracting either map feature points or traffic signs within a bounding box")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"bbox")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 Bounding box coordinates as argument")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"layer")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 \u2018points\u2019 or \u2018traffic_signs\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filter_values")," (",(0,n.kt)("em",{parentName:"li"},"list"),") \u2013 a list of filter values supported by the API.")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 Chronological filters"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"str\n")),(0,n.kt)("h2",{parentName:"li",id:"mapillarycontrollerimage-module"},"mapillary.controller.image module"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollersimage"},"mapillary.controllers.image"),(0,n.kt)("p",{parentName:"li"},"This module implements the image filtering and analysis business logic functionalities of the\nMapillary Python SDK."),(0,n.kt)("p",{parentName:"li"},"For more information, please check out ",(0,n.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerimagegeojson_features_controllergeojson-dict-is_image-bool--true-filters-optionaldict--none"},"mapillary.controller.image.geojson_features_controller(geojson: dict, is_image: bool = True, filters: Optional","[dict]"," = None)"),(0,n.kt)("p",{parentName:"li"},"For extracting images that lie within a GeoJSON and merges the results of the found\nGeoJSON(s) into a single object - by merging all the features into one feature list.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"geojson")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 The geojson to act as the query extent")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"is_image")," (",(0,n.kt)("em",{parentName:"li"},"bool"),") \u2013 Is the feature extraction for images? True for images, False for map features\nDefaults to True")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters")," (",(0,n.kt)("em",{parentName:"li"},"dict",(0,n.kt)("strong",{parentName:"em"}," ("),"kwargs**)"),") \u2013 Different filters that may be applied to the output, defaults to {}")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.zoom")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 The zoom level to obtain vector tiles for, defaults to 14")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.max_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.min_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.image_type")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See ",(0,n.kt)("a",{parentName:"li",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/")," under\n\u2018image_type Tiles\u2019 for more information")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.compass_angle")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 The compass angle of the image")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.sequence_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 ID of the sequence this image belongs to")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.organization_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 ID of the organization this image belongs to. It can be absent")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.layer")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The specified image layer, either \u2018overview\u2019, \u2018sequence\u2019, \u2018image\u2019\nif is_image is True, defaults to \u2018image\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.feature_type")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The specified map features, either \u2018point\u2019 or \u2018traffic_signs\u2019\nif is_image is False, defaults to \u2018point\u2019"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Raises")),(0,n.kt)("p",{parentName:"li"},"  ",(0,n.kt)("strong",{parentName:"p"},"InvalidKwargError")," \u2013 Raised when a function is called with the invalid keyword argument(s)\nthat do not belong to the requested API end call")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  A feature collection as a GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"dict\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerimageget_image_close_to_controllerlongitude-float-latitude-float-kwargs-dict"},"mapillary.controller.image.get_image_close_to_controller(longitude: float, latitude: float, kwargs: dict)"),(0,n.kt)("p",{parentName:"li"},"Extracting the GeoJSON for the image data near the ","[longitude, latitude]"," coordinates")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 The kwargs for the filter")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"longitude")," (",(0,n.kt)("em",{parentName:"li"},"float"),") \u2013 The longitude")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"latitude")," (",(0,n.kt)("em",{parentName:"li"},"float"),") \u2013 The latitude")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs.zoom")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 The zoom level of the tiles to obtain, defaults to 14")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs.min_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The minimum date to filter till")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs.max_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The maximum date to filter upto")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs.image_type")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs.organization_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The organization to retrieve the data for")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"kwargs.radius")," (",(0,n.kt)("em",{parentName:"li"},"float"),") \u2013 The radius that the geometry points will lie in"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"dict\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerimageget_image_from_key_controllerkey-int-fields-list"},"mapillary.controller.image.get_image_from_key_controller(key: int, fields: list)"),(0,n.kt)("p",{parentName:"li"},"A controller for getting properties of a certain image given the image key and\nthe list of fields/properties to be returned")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"key")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 The image key")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"fields")," (",(0,n.kt)("em",{parentName:"li"},"list"),") \u2013 The list of fields to be returned"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  The requested image properties in GeoJSON format")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"str\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerimageget_image_looking_at_controllerlooker-dict-at-dict-filters-dict"},"mapillary.controller.image.get_image_looking_at_controller(looker: dict, at: dict, filters: dict)"),(0,n.kt)("p",{parentName:"li"},"Extracting the GeoJSON for the image data from a \u2018looker\u2019 and \u2018at\u2019 coordinate view")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 Filters to pass the data through")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"looker")," (",(0,n.kt)("em",{parentName:"p"},"dict"),") \u2013 The dictionary of coordinates of the position of the looking from\ncoordinates. Format:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},">>> {\n>>>     'lng': 'longitude',\n>>>     'lat': 'latitude'\n>>> }\n")))),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"at")," (",(0,n.kt)("em",{parentName:"p"},"dict"),") \u2013 The dict of coordinates of the position of the looking at\ncoordinates. Format:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},">>> {\n>>>     'lng': 'longitude',\n>>>     'lat': 'latitude'\n>>> }\n")))),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.min_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The minimum date to filter till")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.max_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The maximum date to filter upto")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.radius")," (",(0,n.kt)("em",{parentName:"li"},"float"),") \u2013 The radius that the geometry points will lie in")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.image_type")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.organization_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The organization to retrieve the data for"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"dict\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerimageget_image_thumbnail_controllerimage_id-str-resolution-int"},"mapillary.controller.image.get_image_thumbnail_controller(image_id: str, resolution: int)"),(0,n.kt)("p",{parentName:"li"},"This controller holds the business logic for retrieving\nan image thumbnail with a specific resolution (256, 1024, or 2048)\nusing an image ID/key")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"image_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 Image key as the argument")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"resolution")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 Option for the thumbnail size, with available resolutions:\n256, 1024, and 2048"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  A URL for the thumbnail")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"str\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerimageget_images_in_bbox_controllerbounding_box-dict-layer-str-zoom-int-filters-dict"},"mapillary.controller.image.get_images_in_bbox_controller(bounding_box: dict, layer: str, zoom: int, filters: dict)"),(0,n.kt)("p",{parentName:"li"},"For getting a complete list of images that lie within a bounding box,\nthat can be filtered via the filters argument")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"bounding_box")," (",(0,n.kt)("em",{parentName:"p"},"dict"),") \u2013 A bounding box representation\nExample:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},">>> {\n...     'west': 'BOUNDARY_FROM_WEST',\n...     'south': 'BOUNDARY_FROM_SOUTH',\n...     'east': 'BOUNDARY_FROM_EAST',\n...     'north': 'BOUNDARY_FROM_NORTH'\n... }\n")))),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"zoom")," \u2013 The zoom level")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"zoom")," \u2013 int")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"layer")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 Either \u2018image\u2019, \u2018sequence\u2019, \u2018overview\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 Filters to pass the data through")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.max_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The max date that can be filtered upto")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.min_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The min date that can be filtered from")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.image_type")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 Either \u2018pano\u2019, \u2018flat\u2019 or \u2018all\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.compass_angle")," (",(0,n.kt)("em",{parentName:"li"},"float"),") \u2013 ")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.organization_id")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 ")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.sequence_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 "))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Raises")),(0,n.kt)("p",{parentName:"li"},"  ",(0,n.kt)("strong",{parentName:"p"},"InvalidKwargError")," \u2013 Raised when a function is called with the invalid keyword argument(s)\nthat do not belong to the requested API end call")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"str\n")),(0,n.kt)("p",{parentName:"li"},"Reference,")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/#coverage-tiles"},"https://www.mapillary.com/developer/api-documentation/#coverage-tiles")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerimageshape_features_controllershape-is_image-bool--true-filters-optionaldict--none"},"mapillary.controller.image.shape_features_controller(shape, is_image: bool = True, filters: Optional","[dict]"," = None)"),(0,n.kt)("p",{parentName:"li"},"For extracting images that lie within a shape, merging the results of the found features\ninto a single object - by merging all the features into one list in a feature collection."),(0,n.kt)("p",{parentName:"li"},"The shape format is as follows:"),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},'>>> {\n...     "type": "FeatureCollection",\n...     "features": [\n...         {\n...             "type": "Feature",\n...             "properties": {},\n...             "geometry": {\n...                 "type": "Polygon",\n...                 "coordinates": [\n...                     [\n...                        [\n...                              7.2564697265625,\n...                             43.69716905314008\n...                         ],\n...                         ...\n...                     ]\n...                 ]\n...             }\n...         }\n...     ]\n... }\n'))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"shape")," (",(0,n.kt)("em",{parentName:"li"},"dict"),") \u2013 A shape that describes features, formatted as a geojson")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"is_image")," (",(0,n.kt)("em",{parentName:"li"},"bool"),") \u2013 Is the feature extraction for images? True for images, False for map features\nDefaults to True")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters")," (",(0,n.kt)("em",{parentName:"li"},"dict",(0,n.kt)("strong",{parentName:"em"}," ("),"kwargs**)"),") \u2013 Different filters that may be applied to the output, defaults to {}")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.max_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The max date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.min_captured_at")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The min date. Format from \u2018YYYY\u2019, to \u2018YYYY-MM-DDTHH:MM:SS\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.image_type")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The tile image_type to be obtained, either as \u2018flat\u2019, \u2018pano\u2019\n(panoramic), or \u2018all\u2019. See ",(0,n.kt)("a",{parentName:"li",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/")," under\n\u2018image_type Tiles\u2019 for more information")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.compass_angle")," (",(0,n.kt)("em",{parentName:"li"},"int"),") \u2013 The compass angle of the image")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.sequence_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 ID of the sequence this image belongs to")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.organization_id")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 ID of the organization this image belongs to. It can be absent")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.layer")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The specified image layer, either \u2018overview\u2019, \u2018sequence\u2019, \u2018image\u2019\nif is_image is True, defaults to \u2018image\u2019")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"filters.feature_type")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The specified map features, either \u2018point\u2019 or \u2018traffic_signs\u2019\nif is_image is False, defaults to \u2018point\u2019"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Raises")),(0,n.kt)("p",{parentName:"li"},"  ",(0,n.kt)("strong",{parentName:"p"},"InvalidKwargError")," \u2013 Raised when a function is called with the invalid keyword argument(s)\nthat do not belong to the requested API end call")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  A feature collection as a GeoJSON")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"dict\n")),(0,n.kt)("h2",{parentName:"li",id:"mapillarycontrollersave-module"},"mapillary.controller.save module"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerssave"},"mapillary.controllers.save"),(0,n.kt)("p",{parentName:"li"},"This module implements the saving business logic functionalities of the Mapillary Python SDK."),(0,n.kt)("p",{parentName:"li"},"For more information, please check out ",(0,n.kt)("a",{parentName:"p",href:"https://www.mapillary.com/developer/api-documentation/"},"https://www.mapillary.com/developer/api-documentation/"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"License: MIT LICENSE"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollersavesave_as_csv_controllerdata-str-path-str-file_name-str"},"mapillary.controller.save.save_as_csv_controller(data: str, path: str, file_name: str)"),(0,n.kt)("p",{parentName:"li"},"Save data as CSV to given file path")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"data")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The data to save as CSV")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"path")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The path to save to")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"file_name")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The file name to save as"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  None")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"None\n")),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollersavesave_as_geojson_controllerdata-str-path-str-file_name-str"},"mapillary.controller.save.save_as_geojson_controller(data: str, path: str, file_name: str)"),(0,n.kt)("p",{parentName:"li"},"Save data as GeoJSON to given file path")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Parameters")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"data")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The data to save as GeoJSON")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"path")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The path to save to")),(0,n.kt)("ul",{parentName:"li"},(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("strong",{parentName:"li"},"file_name")," (",(0,n.kt)("em",{parentName:"li"},"str"),") \u2013 The file name to save as"))),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Returns")),(0,n.kt)("p",{parentName:"li"},"  None")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},(0,n.kt)("strong",{parentName:"p"},"Return type")),(0,n.kt)("pre",{parentName:"li"},(0,n.kt)("code",{parentName:"pre"},"None\n")),(0,n.kt)("h2",{parentName:"li",id:"module-contents"},"Module contents"),(0,n.kt)("h3",{parentName:"li",id:"mapillarycontrollerinit"},"mapillary.controller.",(0,n.kt)("strong",{parentName:"h3"},"init")),(0,n.kt)("p",{parentName:"li"},"This package contains all the business logic implementations of interfaces used within the\nMapillary Python SDK.")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"Copyright: (c) 2021 Facebook")),(0,n.kt)("li",{parentName:"ul"},(0,n.kt)("p",{parentName:"li"},"License: MIT LICENSE"))))}N.isMDXComponent=!0}}]);